
    <!DOCTYPE html>
    <html lang="en"
            
    >
    <head>
    <meta charset="utf-8">
    
    
    <title>
        Java面试题 |
        
        小白的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="1.Java基础1.面向对象的特征有哪些方面抽象：就是将一类对象共同特征总结出来构造类的过程，包括行为抽象和数据抽象两方面 封装：隐藏了类的内部实现细节，并对外提供了接口访问，提高了代码的安全性 继承：子类继承父类，提高了代码的重用性，子类也称为派生类，父类也称为超类或基类 多态：同样的对象调用同样的方法但是做了不同的是，提高了代码的可维护性，可扩展性 （实现多态的方法有：重载（overload）">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题">
<meta property="og:url" content="https://rxxyandysfx.github.io/2023/07/04/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="小白的博客">
<meta property="og:description" content="1.Java基础1.面向对象的特征有哪些方面抽象：就是将一类对象共同特征总结出来构造类的过程，包括行为抽象和数据抽象两方面 封装：隐藏了类的内部实现细节，并对外提供了接口访问，提高了代码的安全性 继承：子类继承父类，提高了代码的重用性，子类也称为派生类，父类也称为超类或基类 多态：同样的对象调用同样的方法但是做了不同的是，提高了代码的可维护性，可扩展性 （实现多态的方法有：重载（overload）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://rxxyandysfx.github.io/url=https:/s1.ax1x.com/2022/09/15/vx4Bh8.png">
<meta property="og:image" content="https://rxxyandysfx.github.io/url=https:/s1.ax1x.com/2022/09/15/vx4s1g.png">
<meta property="og:image" content="https://rxxyandysfx.github.io/url=https:/s1.ax1x.com/2022/09/15/vx4s1g.png">
<meta property="og:image" content="https://rxxyandysfx.github.io/url=https:/s1.ax1x.com/2022/09/19/x9K6oT.png">
<meta property="og:image" content="https://rxxyandysfx.github.io/url=https:/s1.ax1x.com/2022/09/16/xS3iuR.png">
<meta property="article:published_time" content="2023-07-04T01:51:13.702Z">
<meta property="article:modified_time" content="2023-07-04T01:57:03.357Z">
<meta property="article:author" content="小白">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rxxyandysfx.github.io/url=https:/s1.ax1x.com/2022/09/15/vx4Bh8.png">
    
        <link rel="alternate" href="/atom.xml" title="小白的博客" type="application/atom+xml">
    
    
        <link rel="shortcut icon" href="/images/favicon.ico">
    
    
        
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

    
    
<link rel="stylesheet" href="/css/style.css">

    
        
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox.css">

    
    
    
<script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>
  
    <body>
    <div id="container">
        <div id="wrap">
            <header id="header">
    
        <img data-src="https://img2.baidu.com/it/u=3310830304,4274356546&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=400&amp;h=401" data-sizes="auto" alt="Java面试题" class="lazyload">
    
    <div id="header-outer" class="outer">
        <div id="header-title" class="inner">
            <h1 id="logo-wrap">
                
                    
                    
                        <a href="/" id="logo">Java面试题</a>
                    
                
            </h1>
            
                
                
            
        </div>
        <div id="header-inner">
            <nav id="main-nav">
                <a id="main-nav-toggle" class="nav-icon"></a>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/">首页</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/archives">归档</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/about">关于</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/friend">友链</a>
                    </span>
                
            </nav>
            <nav id="sub-nav">
                
                    <a id="nav-rss-link" class="nav-icon" href="/atom.xml"
                       title="RSS 订阅"></a>
                
                
            </nav>
            <div id="search-form-wrap">
                <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rxxyandysfx.github.io"></form>
            </div>
        </div>
    </div>
</header>
  
            <div id="content" class="outer">
                <section id="main"><article id="post-面试题" class="h-entry article article-type-post"
         itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
    <div class="article-inner">
        <div class="article-meta">
            <div class="article-date">
    <a href="/2023/07/04/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date-link">
        <time datetime="2023-07-04T01:51:13.702Z"
              itemprop="datePublished">2023-07-04</time>
    </a>
</div>

            
        </div>
        <div class="hr-line"></div>
        
        <div class="e-content article-entry" itemprop="articleBody">
            
                <h3 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1.Java基础"></a>1.Java基础</h3><h4 id="1-面向对象的特征有哪些方面"><a href="#1-面向对象的特征有哪些方面" class="headerlink" title="1.面向对象的特征有哪些方面"></a>1.面向对象的特征有哪些方面</h4><p>抽象：就是将一类对象共同特征总结出来构造类的过程，包括行为抽象和数据抽象两方面</p>
<p>封装：隐藏了类的内部实现细节，并对外提供了接口访问，提高了代码的安全性</p>
<p>继承：子类继承父类，提高了代码的重用性，子类也称为派生类，父类也称为超类或基类</p>
<p>多态：同样的对象调用同样的方法但是做了不同的是，提高了代码的可维护性，可扩展性</p>
<p>（实现多态的方法有：重载（overload），重写（override）,向上转型（upload））</p>
<h4 id="2-访问修饰的区别"><a href="#2-访问修饰的区别" class="headerlink" title="2.访问修饰的区别"></a>2.访问修饰的区别</h4><p>public（公共的）:同包，本类，子类，其他包</p>
<p>protected（受保护的）:本类，同包，子类</p>
<p>default（默认的）:本类，同包</p>
<p>private（私有的）本类</p>
<h4 id="3-String是最基本的数据类型吗？"><a href="#3-String是最基本的数据类型吗？" class="headerlink" title="3.String是最基本的数据类型吗？"></a>3.String是最基本的数据类型吗？</h4><p>不是，Java中最基本的数据类型有八个：byte，int，char，long，float，double，boolean，short；</p>
<p>除了基本类型（primitivetype），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<h4 id="4-float-f-x3D-3-4-是否正确"><a href="#4-float-f-x3D-3-4-是否正确" class="headerlink" title="4.float f&#x3D;3.4;是否正确"></a>4.float f&#x3D;3.4;是否正确</h4><p>float f&#x3D;3.4由于3.4是双精度数，赋值给单精度会造成精度损失，属于向下转型（down-casting,也称为窄化）、因此需要强制类型转换float f &#x3D; (float)3.4或者直接写成float f &#x3D; 34F</p>
<h4 id="5-short-s1-x3D-1-s1-x3D-s1-1-short-s1-x3D-1-s1-x3D-1有错吗？为什么"><a href="#5-short-s1-x3D-1-s1-x3D-s1-1-short-s1-x3D-1-s1-x3D-1有错吗？为什么" class="headerlink" title="5.short s1&#x3D;1;s1&#x3D;s1+1;short s1&#x3D;1,s1+&#x3D;1有错吗？为什么"></a>5.short s1&#x3D;1;s1&#x3D;s1+1;short s1&#x3D;1,s1+&#x3D;1有错吗？为什么</h4><p>由于这个1是整形int赋值给short需要强制类型转换short s1&#x3D;1,s1&#x3D;(short)s1+1；而short s1&#x3D;1,s1+&#x3D;1其中有隐式的强制类型转换	</p>
<h4 id="6-Java有没有goto"><a href="#6-Java有没有goto" class="headerlink" title="6.Java有没有goto?"></a>6.Java有没有goto?</h4><p>没有goto是C++中的关键字，在Java中是保留字，在目前版本的没有使用</p>
<p>使用了这个标签技术来替代了C++里面goto关键子的作用</p>
<h4 id="7-int和Integer的区别"><a href="#7-int和Integer的区别" class="headerlink" title="7.int和Integer的区别"></a>7.int和Integer的区别</h4><p>（1）Integer是int的包装类，int是基本的数据类型</p>
<p>（2）Integer必须实例化后才能使用，int变量不需要</p>
<p>（3）Integer实际是对象的引用，指向此new的Integer对象，int是直接存储数据值</p>
<p>（4）Integer的默认值是null,int的默认值是0</p>
<p>（5）Integer比较必须使用eq,int则是&#x3D;&#x3D;</p>
<h4 id="8-amp-与-amp-amp-的区别"><a href="#8-amp-与-amp-amp-的区别" class="headerlink" title="8.&amp;与&amp;&amp;的区别"></a>8.&amp;与&amp;&amp;的区别</h4><p>&amp;：按位与，假如判断的时候前面的值是true是会判断后面的值，没有短路</p>
<p>&amp;&amp;：逻辑与，如果前面的值false，就不会去判断后面的值，具有短路功能</p>
<h4 id="9-解释一下内存中的栈（stack）、堆（heap）、方法区（method-area）的用法。堆和栈的区别？"><a href="#9-解释一下内存中的栈（stack）、堆（heap）、方法区（method-area）的用法。堆和栈的区别？" class="headerlink" title="9.解释一下内存中的栈（stack）、堆（heap）、方法区（method area）的用法。堆和栈的区别？"></a>9.解释一下内存中的栈（stack）、堆（heap）、方法区（method area）的用法。堆和栈的区别？</h4><img src="/url=https:/s1.ax1x.com/2022/09/15/vx4Bh8.png" class="" title="title&#x3D;类型默认值">

<img src="/url=https:/s1.ax1x.com/2022/09/15/vx4s1g.png" class="" title="title&#x3D;JVM存储原理">

<p>栈内存：通常我们声明的基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间</p>
<p>堆内存：而通常我们new出来的对象还有对象里面的实例变量存储在这个堆空间，堆是垃圾回收机制（gc）主要管理的区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以分为新生代和老生代，</p>
<p>方法区：方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、，JIT编译器编译后的代码等数据</p>
<p>区别：</p>
<p>不同：</p>
<p>（1）堆内存用来存放由new产生的对象和数组</p>
<p>（2）栈内存用来存放方法和局部变量</p>
<p>（3）堆内存是先进先出</p>
<p>（4）栈内存是后进后出</p>
<p>相同：</p>
<p>（1）都是Java内存的一种，</p>
<p>（2）系统都会自动回收它，但对于堆内存开发人员一般会自动去回收它</p>
<p>对象和引用的区别：</p>
<p>（1）对象是存储在堆内存里面的由new产生空间存储</p>
<p>（2）但凡是变量，并且该变量中保存了内存地址指向堆内存里面存储的对象</p>
<h4 id="10-math-round-11-5-和math-round-11-5-都等于多少？"><a href="#10-math-round-11-5-和math-round-11-5-都等于多少？" class="headerlink" title="10.math.round(11.5)和math.round(-11.5)都等于多少？"></a>10.math.round(11.5)和math.round(-11.5)都等于多少？</h4><p>12,-11</p>
<h4 id="11-swith是否能作用在byte上，是否能作用在long上，是否能作用在String上？"><a href="#11-swith是否能作用在byte上，是否能作用在long上，是否能作用在String上？" class="headerlink" title="11.swith是否能作用在byte上，是否能作用在long上，是否能作用在String上？"></a>11.swith是否能作用在byte上，是否能作用在long上，是否能作用在String上？</h4><p>在Java5以前swith只能是byte，short，chat，int</p>
<p>从Java5开始，Java中引入了枚举类型</p>
<p>枚举类型就是为了好看，给人看的，不是给机器看的</p>
<p>从Java7开始，swith也可以是String</p>
<p>但是Long在Java目前所有版本都是不可以的</p>
<h4 id="12-用最有效率的方式计算2乘以八"><a href="#12-用最有效率的方式计算2乘以八" class="headerlink" title="12.用最有效率的方式计算2乘以八"></a>12.用最有效率的方式计算2乘以八</h4><p>2&lt;&lt;3相当于2乘以2的3次方</p>
<h4 id="13-数组有没有lengtn-方法？String有没有length-方法？"><a href="#13-数组有没有lengtn-方法？String有没有length-方法？" class="headerlink" title="13.数组有没有lengtn()方法？String有没有length()方法？"></a>13.数组有没有lengtn()方法？String有没有length()方法？</h4><p>数组有lengtn属性没有length方法，String有length方法</p>
<h4 id="14-在Java中，如何跳出当前的多重嵌套循环？"><a href="#14-在Java中，如何跳出当前的多重嵌套循环？" class="headerlink" title="14.在Java中，如何跳出当前的多重嵌套循环？"></a>14.在Java中，如何跳出当前的多重嵌套循环？</h4><p>在最外层加一个便签lable比如A，然后使用break A跳出多重循环（Java中带标签的break和continue语句，作用类似C++里面的goto关键字）</p>
<h4 id="15-构造器是否可以被重写（override）"><a href="#15-构造器是否可以被重写（override）" class="headerlink" title="15.构造器是否可以被重写（override）"></a>15.构造器是否可以被重写（override）</h4><p>构造器不能被继承当然不能被重写（override）当时可以重载（overload）</p>
<h4 id="16-两个对象值相同（x-equals-y-x3D-x3D-true），但却有不同的hash-code，这句话对不对？"><a href="#16-两个对象值相同（x-equals-y-x3D-x3D-true），但却有不同的hash-code，这句话对不对？" class="headerlink" title="16.两个对象值相同（x.equals(y)&#x3D;&#x3D;true），但却有不同的hash code，这句话对不对？"></a>16.两个对象值相同（x.equals(y)&#x3D;&#x3D;true），但却有不同的hash code，这句话对不对？</h4><p>如果它们两个的值相同它们的hash code一定相同</p>
<p>如果它们的hash code相同它们不一定相同</p>
<h4 id="17-String可以被继承吗？"><a href="#17-String可以被继承吗？" class="headerlink" title="17.String可以被继承吗？"></a>17.String可以被继承吗？</h4><p>String是final（常量）类，不能被继承</p>
<p>注意：继承String类本身就是错误，对于String最好的关系是依赖关系和关联关系</p>
<h4 id="18-当一个对象被当做参数传递到一个方法后，此方法可以改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#18-当一个对象被当做参数传递到一个方法后，此方法可以改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="18.当一个对象被当做参数传递到一个方法后，此方法可以改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>18.当一个对象被当做参数传递到一个方法后，此方法可以改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><p>是值传递</p>
<h4 id="19-String和StringBuffer-x2F-StringBuilder的区别"><a href="#19-String和StringBuffer-x2F-StringBuilder的区别" class="headerlink" title="19.String和StringBuffer&#x2F;StringBuilder的区别"></a>19.String和StringBuffer&#x2F;StringBuilder的区别</h4><p>他们都是Java提供的字符串类型</p>
<p>String：只能读取值，不能对值进行一个修改</p>
<p>StringBuffer&#x2F;StringBuilder:能直接对值进行一个修改</p>
<p>StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</p>
<h4 id="20-override和overload的区别？"><a href="#20-override和overload的区别？" class="headerlink" title="20.override和overload的区别？"></a>20.override和overload的区别？</h4><p>override：重写，子类重写父类方法，要求方法签名一致，返回值不同，参数列表一致</p>
<p>overload：重载，发生在一个类中，方法名一致，参数列表不同则视为重载，对返回值没有特别要求</p>
<h4 id="21-描述一下JVM（java-VM）加载class文件的原理机制"><a href="#21-描述一下JVM（java-VM）加载class文件的原理机制" class="headerlink" title="21.描述一下JVM（java VM）加载class文件的原理机制"></a>21.描述一下JVM（java VM）加载class文件的原理机制</h4><img src="/url=https:/s1.ax1x.com/2022/09/15/vx4s1g.png" class="" title="title&#x3D;JVM存储原理">

<p>JVM加载class文件的原理机制：</p>
<p>（1）Java中的类</p>
<p>1）系统类</p>
<p>2）扩展类</p>
<p>3）由程序员自定义类</p>
<p>（2）类装载的方式</p>
<p>1）隐式装载，程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到JVM中</p>
<p>2）显示装载，通过class.forName()等方法，显示加载需要的类</p>
<p>（3）类加载的动态性体现</p>
<p>一个应用程序总是由n多个类组成，java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到JVM中，其他的类等到jvm用到的时候再加载，这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，这是一种可以理解的机制，再用到时加载这也是java动态性的一种体现</p>
<p>（4）java类装载器</p>
<p> Java中的类装载器实质上也是类，功能是把类载入jvm中，值得注意的是jvm的类装载器并不是一个，而是三个，层次结构如下：<br>      Bootstrap Loader  - 负责加载系统类<br>            |<br>          - - ExtClassLoader  - 负责加载扩展类<br>                          |<br>                      - - AppClassLoader  - 负责加载应用类<br>        为什么要有三个类加载器，一方面是分工，各自负责各自的区块，另一方面为了实现委托模型，下面会谈到该模型</p>
<ol>
<li>Bootstrap类加载器 – JRE&#x2F;lib&#x2F;rt.jar</li>
<li>Extension类加载器 – JRE&#x2F;lib&#x2F;ext或者java.ext.dirs指向的目录</li>
<li>Application类加载器 – CLASSPATH环境变量, 由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义.</li>
</ol>
<p>（5）类加载器之间是如何协调工作的</p>
<p>1）委托机制</p>
<p>当一个类加载和初始化的时候，类仅在有需要加载的时候被加载。假设你有一个应用需要的类叫作Abc.class，首先加载这个类的请求由 Application类加载器委托给它的父类加载器Extension类加载器，然后再委托给Bootstrap类加载器。Bootstrap类加载器 会先看看rt.jar中有没有这个类，因为并没有这个类，所以这个请求由回到Extension类加载器，它会查看jre&#x2F;lib&#x2F;ext目录下有没有这 个类，如果这个类被Extension类加载器找到了，那么它将被加载，而Application类加载器不会加载这个类；而如果这个类没有被 Extension类加载器找到，那么再由Application类加载器从classpath中寻找。记住classpath定义的是类文件的加载目 录，而PATH是定义的是可执行程序如javac，java等的执行路径。</p>
<p>2）可见性机制</p>
<p>可见性的原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类。</p>
<p>3）单一性机制</p>
<p>根据这个机制，父加载器加载过的类不能被子加载器加载第二次。虽然重写违反委托和单一性机制的类加载器是可能的，但这样做并不可取。</p>
<p>（6）类的加载过程</p>
<ol>
<li>装载：查找并加载类的二进制数据；<br> 2)链接：<br> 验证：确保被加载类的正确性；<br> 准备：为类的静态变量分配内存，并将其初始化为默认值；<br> 解析：把类中的符号引用转换为直接引用；<br> 3)初始化：为类的静态变量赋予正确的初始值；<br>   那为什么我要有验证这一步骤呢？首先如果由编译器生成的class文件，它肯定是符合JVM字节码格式的，但是万一有高手自己写一个class文件，让JVM加载并运行，用于恶意用途，就不妙了，因此这个class文件要先过验证这一关，不符合的话不会让它继续执行的，也是为了安全考虑吧。<br> 准备阶段和初始化阶段看似有点牟盾，其实是不牟盾的，如果类中有语句：private static int a &#x3D; 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a&#x3D;0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a&#x3D;10。</li>
</ol>
<p>（7）类的初始化</p>
<p>1）创建类的实例，也就是new一个对象<br>2）访问某个类或接口的静态变量，或者对该静态变量赋值<br>3）调用类的静态方法<br>4）反射（Class.forName(“com.lyj.load”)）<br>5）初始化一个类的子类（会首先初始化子类的父类）<br>6）JVM启动时标明的启动类，即文件名和类名相同的那个类<br>         只有这6中情况才会导致类的类的初始化。<br>     类的初始化步骤：<br>        1）如果这个类还没有被加载和链接，那先进行加载和链接<br>        2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）<br>         3)加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。</p>
<p>JVM运行原理：</p>
<p>首先由这个方法区使用这个类加载器（classload）先加载这个类然后创建main方法压栈在new对象相当于在堆内存中开辟一块空间，引用就是栈内存里面的引用指向堆内存里面的实例对象，使用完后堆内存是先进先出，后进后出，栈内存是先进后出，后进先出。</p>
<p>主要有以下四种类加载器：</p>
<p>　　1、启动类加载器（Bootstrap ClassLoader）用来加载java核心类库，无法被java程序直接引用。</p>
<p>　　2、扩展类加载器（Extensions ClassLoader）用来加载java的扩展库。java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载java类，它的父类加载器是Bootrap。</p>
<p>　　3、系统类加载器（System ClassLoader）根据java应用的类路径（CLASSPATH）来加载java类。一般来说，java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemLoader()来获取它，它是应用最广泛的类加载器。。</p>
<p>　　4、用户自定义类加载器，通过继承java.lang.ClassLoader类的方式实现。</p>
<h4 id="22-char型变量中能不能存贮一个中文汉字，为什么？"><a href="#22-char型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="22.char型变量中能不能存贮一个中文汉字，为什么？"></a>22.char型变量中能不能存贮一个中文汉字，为什么？</h4><p>char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。</p>
<h4 id="23-抽象类和接口的区别"><a href="#23-抽象类和接口的区别" class="headerlink" title="23.抽象类和接口的区别"></a>23.抽象类和接口的区别</h4><p>相同：</p>
<p>（1）都可以存在抽象方法</p>
<p>（2）都可以被继承</p>
<p>（3）不能被实现</p>
<p>（4）普通子类都需要重写抽象方法</p>
<p>不同：</p>
<p>（1）关键字不同 接口（interface）抽象类（abstract class）</p>
<p>（2）抽象类可以有普通方法，接口不能</p>
<p>（3）类继承抽象类，接口继承接口</p>
<h4 id="24-静态嵌套类（Static-Nested-Class）和内部类-Inner-Class-的区别？"><a href="#24-静态嵌套类（Static-Nested-Class）和内部类-Inner-Class-的区别？" class="headerlink" title="24.静态嵌套类（Static Nested Class）和内部类(Inner Class)的区别？"></a>24.静态嵌套类（Static Nested Class）和内部类(Inner Class)的区别？</h4><p>Static Nested Class是被声明为静态的内部类，它可以不依赖于外部类实例被实例化</p>
<p>Inner Class需要在外部类实例化后才能实例化，其语法看起来挺诡异的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">一般情况下，类和类之间是相互独立的，内部类的意思是打破这种独立，让一个类成为另外一个类的内部信息，和成员变量、成员方法同等级别。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>非静态内部类</span><br><span class="line"></span><br><span class="line">非静态内部类的使用就是将内部类当做外部类的一个成员变量/成员方法来使用，所以必须依赖于外部类的对象才能调用，用法上和成员变量/成员方法是一致的。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String b</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nb</span><span class="params">()</span>&#123;</span><br><span class="line">        	<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        	b.b=<span class="string">&quot;666&quot;</span></span><br><span class="line">        	System.out.println(a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    A.<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>.B();</span><br><span class="line">    b.nb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>局部内部类</span><br><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jiba</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jibab</span><span class="params">()</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;牛逼&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">           <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">           a.jibab();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">    t.jiba();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>静态内部类</span><br><span class="line">静态内部类的构造不需要依赖于外部类对象，类中的所有静态组件都不需要依赖于任何对象，可以直接通过类本身进行构造</span><br><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line">        Integer a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jiba</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">a</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">a</span>();</span><br><span class="line">        a.jiba();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为什么要使用内部类？</span><br><span class="line"></span><br><span class="line">采用内部类这种技术，可以隐藏细节和内部结构，封装性更好，让程序的结构更加合理。（优雅）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="25-Java中会存在内存泄漏吗，请简单描述"><a href="#25-Java中会存在内存泄漏吗，请简单描述" class="headerlink" title="25.Java中会存在内存泄漏吗，请简单描述"></a>25.Java中会存在内存泄漏吗，请简单描述</h4><p>由于Java中有GC（垃圾回收机制）理论上不会存在内存泄漏，但在实际开发中，有无用但可达的对象，这些对象无法被GC回收，因此会导致内存泄漏的发生</p>
<h4 id="26-抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#26-抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="26.抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰"></a>26.抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰</h4><p>都不能。</p>
<p>抽象方法需要子类重写，而静态方法是无法被重写的</p>
<p>本地方法是本地代码实现的，而抽象没有实现</p>
<p>synchronized跟实现细节有关，抽象方法不涉及实现细节</p>
<h4 id="27-阐述静态变量和实例变量"><a href="#27-阐述静态变量和实例变量" class="headerlink" title="27.阐述静态变量和实例变量"></a>27.阐述静态变量和实例变量</h4><p>静态变量是被static修饰过的变量，也称为类变量，他属于类，不属于类的任何一个对象，一个类不管创建多少对象，静态变量在内存中有且仅有一份拷贝，静态变量可以实现多个对个对象共享内存</p>
<p>实例变量必须依存于某一实例，再通过实例才能访问到它</p>
<h4 id="28-是否可以从一个静态（static）方法内部发出对非静态（no-static）方法的调用？"><a href="#28-是否可以从一个静态（static）方法内部发出对非静态（no-static）方法的调用？" class="headerlink" title="28.是否可以从一个静态（static）方法内部发出对非静态（no-static）方法的调用？"></a>28.是否可以从一个静态（static）方法内部发出对非静态（no-static）方法的调用？</h4><p>不可以。静态方法只能访问静态成员，因为非静态方法的调用需要先创建对象，在调用静态方法时可能对象并没有被初始化。</p>
<h4 id="29-如何实现对象克隆"><a href="#29-如何实现对象克隆" class="headerlink" title="29.如何实现对象克隆"></a>29.如何实现对象克隆</h4><p>有两种方式</p>
<p>（1）实现Cloneable接口并重写Object类中的clone()方法</p>
<p>（2）实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正意义上的深度克隆</p>
<h3 id="30-GC是什么？为什么要有GC？"><a href="#30-GC是什么？为什么要有GC？" class="headerlink" title="30.GC是什么？为什么要有GC？"></a>30.GC是什么？为什么要有GC？</h3><p>GC是垃圾收集的意思，内存处理一直都是开发人员最容易出问题的地方，忘记或者错误的内存处理会导致这个系统的不稳定性甚至崩溃，Java中提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理</p>
<p>要请求垃圾回收器可以调用System.gc()或Runtime.gc();</p>
<h4 id="31-String-s-x3D-new-String-“xyz”-创建了几个字符串对象？"><a href="#31-String-s-x3D-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="31.String s&#x3D; new String(“xyz”)创建了几个字符串对象？"></a>31.String s&#x3D; new String(“xyz”)创建了几个字符串对象？</h4><p>两个，一个是new 在堆内存中的对象，一个是静态区的”xyz”</p>
<h4 id="32-接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreateclass）"><a href="#32-接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreateclass）" class="headerlink" title="32.接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreateclass）"></a>32.接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreateclass）</h4><p>接口可以继承接口，而且支持多重继承</p>
<p>抽象类可以实现接口</p>
<p>抽象类可继承具体类，也可以继承抽象类</p>
<h4 id="33-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#33-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="33.一个”.java”源文件中是否可以包含	多个类（不是内部类）？有什么限制？"></a>33.一个”.java”源文件中是否可以包含	多个类（不是内部类）？有什么限制？</h4><p>可以，但是一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致</p>
<h4 id="34-Anonymous-Inner-Class-匿名内部类-是否可以继承其他类？是否可以实现接口？"><a href="#34-Anonymous-Inner-Class-匿名内部类-是否可以继承其他类？是否可以实现接口？" class="headerlink" title="34.Anonymous Inner Class(匿名内部类)是否可以继承其他类？是否可以实现接口？"></a>34.Anonymous Inner Class(匿名内部类)是否可以继承其他类？是否可以实现接口？</h4><p>可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyImplement</span>();</span><br><span class="line">myInterface.test();</span><br><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">myInterface1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">( &#123;</span></span><br><span class="line"><span class="params">                System.out.println( <span class="string">&quot;test&quot;</span> )</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">myInterface1.test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="35-内部类可以引用他的包含类（外部类）的成员吗？有没有什么限制？"><a href="#35-内部类可以引用他的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="35.内部类可以引用他的包含类（外部类）的成员吗？有没有什么限制？"></a>35.内部类可以引用他的包含类（外部类）的成员吗？有没有什么限制？</h4><p>1、外部类访问内部类：</p>
<p>　　　内部类被<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>修饰：可以直接new</p>
<p>　　　　Inner in &#x3D; new Inner();</p>
<p>　　　内部类没有被static修饰:得先new出来<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%96%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">外部类</a>的实例，再new内部类的</p>
<p>　　　　Inner in &#x3D; new Outer().new Inner();</p>
<p>2、内部类访问外部类：（外部类.this.变量）</p>
<p>一个类的内部类对象可以访问创建它的外部类对象的成员，包括私有成员</p>
<h4 id="36-Java中的final关键字有哪些用法？"><a href="#36-Java中的final关键字有哪些用法？" class="headerlink" title="36.Java中的final关键字有哪些用法？"></a>36.Java中的final关键字有哪些用法？</h4><p>（1）final修饰过的类，类不能被继承</p>
<p>（2）final修饰过的属性，常量不能修改值</p>
<p>（3）final修饰过的方法，方法不能被重写</p>
<h4 id="37-指出下面程序的运行结果。"><a href="#37-指出下面程序的运行结果。" class="headerlink" title="37.指出下面程序的运行结果。"></a>37.指出下面程序的运行结果。</h4><p>class A {</p>
<p>​    static {</p>
<p>​        System.out.print(“1”);</p>
<p>​    }</p>
<p>​    public A() {</p>
<p>​        System.out.print(“2”);</p>
<p>​    }</p>
<p>}</p>
<p>class B extends A{</p>
<p>​    static {</p>
<p>​        System.out.print(“a”);</p>
<p>​    }</p>
<p>​    public B() {</p>
<p>​        System.out.print(“b”);</p>
<p>​    }</p>
<p>}</p>
<p>public class Hello {</p>
<p>​    public static void main(String[] args) {</p>
<p>​        A ab &#x3D; new B();</p>
<p>​        ab &#x3D; new B();</p>
<p>​    }</p>
<p>}</p>
<p>答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<h4 id="38-数据类型之间的转换：-如何将字符串转换为基本数据类型？-如何将基本数据类型转换为字符串？"><a href="#38-数据类型之间的转换：-如何将字符串转换为基本数据类型？-如何将基本数据类型转换为字符串？" class="headerlink" title="38.数据类型之间的转换： - 如何将字符串转换为基本数据类型？ - 如何将基本数据类型转换为字符串？"></a>38.数据类型之间的转换： - 如何将字符串转换为基本数据类型？ - 如何将基本数据类型转换为字符串？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//（1）String转换为基本数据类型，使用基本数据类型.parseXXX(String)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;16546&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(a);</span><br><span class="line">        System.out.println(b);<span class="comment">//此处输出是16546</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一种方法是将基本数据类型与空字符串（&quot;&quot;）连接（+）即可获得其所对应的字符串</span></span><br><span class="line">        <span class="comment">//（2）基本数据类型转换为String类型调用String.valueOf(基本数据类型)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">1533123</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> String.valueOf(a1);</span><br><span class="line">        System.out.println(a2);<span class="comment">//此处输出是1533123</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="39-如何实现字符串的反转及替换"><a href="#39-如何实现字符串的反转及替换" class="headerlink" title="39.如何实现字符串的反转及替换"></a>39.如何实现字符串的反转及替换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//（1）调用StringBuffer中的reverse实现字符串的反转</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(a);</span><br><span class="line">        stringBuffer.reverse();</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）实现字符串的替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;字符串的替的换&quot;</span>;</span><br><span class="line">        <span class="comment">//只替换第一个</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> b.replaceFirst(<span class="string">&quot;的&quot;</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//输出了“字符串,替的换”</span></span><br><span class="line">        <span class="comment">//全部进行替换</span></span><br><span class="line">        String d= b.replaceAll(<span class="string">&quot;的&quot;</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(d);<span class="comment">//输出了&quot;字符串,替,换&quot;</span></span><br><span class="line">        <span class="comment">//将新字符替换成旧字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> b.replace(<span class="string">&quot;的&quot;</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(e);<span class="comment">//此处输出&quot;字符串,替,换&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(3)实现字符串的查找</span></span><br><span class="line">       	<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abcdefga&quot;</span>;</span><br><span class="line">        <span class="comment">//查找指定字符第一次出现的位置</span></span><br><span class="line">        <span class="comment">//index(str,fromIndex) str:搜索的字符串 fromIndex索引下标从哪里开始</span></span><br><span class="line">        <span class="type">int</span> first1=a.indexOf(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(first1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(4)实现字符串的截取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abcdefgahigk&quot;</span>;</span><br><span class="line">        <span class="comment">//从索引处到末尾</span></span><br><span class="line">        String first1=a.substring(<span class="number">5</span>);</span><br><span class="line">        System.out.println(first1);<span class="comment">//此处输出fgahigk</span></span><br><span class="line">        <span class="comment">//指定区间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">first2</span> <span class="operator">=</span> a.substring(<span class="number">5</span>,<span class="number">7</span>);<span class="comment">//此处输出fg</span></span><br><span class="line">        System.out.println(first2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(5)实现字符串的分割</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abcdefgahigk&quot;</span>;</span><br><span class="line">        <span class="comment">//regex分割正则表达式</span></span><br><span class="line">        String[] first1 = a.split(<span class="string">&quot;bcde&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String b: first1) &#123;</span><br><span class="line">              System.out.println(b);<span class="comment">//此处输出a    fgahigk</span></span><br><span class="line">         &#125;	</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="40-怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#40-怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="40.怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>40.怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h4><p>字符集如何设计的呢？</p>
<p>我们使用了分区管理，共计94个区，每个区含94个位。共8836个码位</p>
<p>10-15是空白区</p>
<p>存储方式：</p>
<p>ASCLL：ASCLL码是直接将ASCLL字符集的码位装换成二进制进而存储</p>
<p>GB2312：侃码位是5709，57和09分开转换为16进制 ，57对应39，09对应09，然后分别加上A0，39加上A0得到D9，09加上A0得到A9，再将D9和A9合并就是最终侃这个字的GB2312码</p>
<blockquote>
<p>注意：GB2312码：高位和低位都大于127，可以表示6763个汉字</p>
<p>GBK：不再规定低位必须大于127，新增近20000个汉字和符号</p>
<p>GB18030：新增几千少数名族字符</p>
<p>那么问题就来了世界上这么多名族，难道每个名族都设计一个字符集编码吗？</p>
<p>显然并不是的，一个叫ISO的组织看不下去了，他觉得太乱了，是时候要规范一下了，于是Unicode就诞生了</p>
<p>Unicode：它包含了字符集以及对应的编码规则，就是想把世界上所有的字符放在一起</p>
<p>刚出来时因为所需存储空间较大，没有被很好的接受</p>
<p>Unicode一开始使用的是：</p>
<p>UCS-2字符集：可以表示65536个字符</p>
<p>UCS-4字符集：可表示近43亿个字符</p>
<p>UTF-8字符集：使用内存较小</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(s1.getBytes(<span class="string">&quot;GB2312&quot;</span>), <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">//此处输出ÄãºÃ不知道是啥？</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="41-日期和时间：-如何获得年月日、小时分钟秒？如何获得从1970年1月1日0时0分0秒到现在的毫秒数？如何获得某月的最后一天？如何格式化日期"><a href="#41-日期和时间：-如何获得年月日、小时分钟秒？如何获得从1970年1月1日0时0分0秒到现在的毫秒数？如何获得某月的最后一天？如何格式化日期" class="headerlink" title="41.日期和时间：-如何获得年月日、小时分钟秒？如何获得从1970年1月1日0时0分0秒到现在的毫秒数？如何获得某月的最后一天？如何格式化日期"></a>41.日期和时间：-如何获得年月日、小时分钟秒？如何获得从1970年1月1日0时0分0秒到现在的毫秒数？如何获得某月的最后一天？如何格式化日期</h4><p>创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值。Java 8中可以使用java.time.LocalDateTimel来获取，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前年份:&quot;</span>+calendar.get(Calendar.YEAR));<span class="comment">//获取当前年份</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前月份&quot;</span>+calendar.get(Calendar.MONTH)+<span class="number">1</span>);<span class="comment">//获取当前月份但是索引是从0开始所以正确月份得加1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前是&quot;</span>+calendar.get(Calendar.DATE)+<span class="string">&quot;号&quot;</span>);<span class="comment">//获取当前几号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前小时&quot;</span>+calendar.get(Calendar.HOUR_OF_DAY));<span class="comment">//获取当前小时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前分钟&quot;</span>+calendar.get(Calendar.MINUTE));<span class="comment">//获取当前分钟</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前秒数&quot;</span>+calendar.get(Calendar.SECOND));<span class="comment">//获取当前秒数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 8</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(dt.getYear());<span class="comment">//获取当前年份</span></span><br><span class="line">        System.out.println(dt.getMonthValue());<span class="comment">// 1 - 12</span></span><br><span class="line">        System.out.println(dt.getDayOfMonth());<span class="comment">//获取当前几号</span></span><br><span class="line">        System.out.println(dt.getHour());<span class="comment">//获取当前小时</span></span><br><span class="line">        System.out.println(dt.getMinute());<span class="comment">//获取当前分钟</span></span><br><span class="line">        System.out.println(dt.getSecond());<span class="comment">//获取当前秒数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong>Java的时间日期API一直以来都是被诟病的东西，为了解决这一问题，Java<br>8中引入了新的时间日期API，其中包括LocalDate、LocalTime、LocalDateTime、Clock、Instant等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。</p>
<h4 id="42-打印昨天的当前时刻。"><a href="#42-打印昨天的当前时刻。" class="headerlink" title="42.打印昨天的当前时刻。"></a>42.打印昨天的当前时刻。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.DATE,-<span class="number">1</span>);</span><br><span class="line">        System.out.println(calendar.getTime());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Java8</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">today</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">yesterday</span> <span class="operator">=</span> today.minusDays(<span class="number">1</span>);</span><br><span class="line">        System.out.println(yesterday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="43-比较一下Java和JavaScript"><a href="#43-比较一下Java和JavaScript" class="headerlink" title="43.比较一下Java和JavaScript"></a>43.比较一下Java和JavaScript</h4><p>Java和JS是两个公司开发的不同产品。</p>
<p>Java：Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发</p>
<p>JS：Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可嵌入Web页面中运行的基于对象和事件驱动的解释性语言。</p>
<h4 id="44-什么时候用断言？"><a href="#44-什么时候用断言？" class="headerlink" title="44.什么时候用断言？"></a>44.什么时候用断言？</h4><p>断言是一种调试方式，断言失败会抛出AssertionError</p>
<p>只能在开发和测试阶段启用断言</p>
<p>对可恢复的错误不能使用断言，而应该抛出异常</p>
<p>断言很少被使用，更好的方法是编写单元测试</p>
<h4 id="45-Error和Exception有什么区别？"><a href="#45-Error和Exception有什么区别？" class="headerlink" title="45.Error和Exception有什么区别？"></a>45.Error和Exception有什么区别？</h4><img src="/url=https:/s1.ax1x.com/2022/09/19/x9K6oT.png" class="" title="title&#x3D;">

<p>异常的基类是java.lang.Throwable</p>
<p>Error：是程序中无法处理的错误，只能事先避免。表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题，错误发生时，JVM将终止线程。如OutOfMemoryError内存溢出、StackOverFlowError栈溢出。</p>
<p>Exception:程序本身可以捕获并且可以处理的异常</p>
<h4 id="46-try-后面有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候执行，在return前还是后？"><a href="#46-try-后面有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候执行，在return前还是后？" class="headerlink" title="46.try{}后面有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候执行，在return前还是后？"></a>46.try{}后面有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候执行，在return前还是后？</h4><p>会执行，在方法返回调用者前执行。</p>
<h5 id="47-Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用"><a href="#47-Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用" class="headerlink" title="47.Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用"></a>47.Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用</h5><p>try:用来监听可能出现的异常</p>
<p>catch:用来捕获出现的异常</p>
<p>finally:为确保一段代码不管发生什么异常状况都要被执行，一般用于释放资源</p>
<p>throw:抛出异常</p>
<p>throws:声明一个方法可能抛出的异常</p>
<h4 id="48-运行时异常与受检查异常有何异同？"><a href="#48-运行时异常与受检查异常有何异同？" class="headerlink" title="48.运行时异常与受检查异常有何异同？"></a>48.运行时异常与受检查异常有何异同？</h4><p>异常就是指各种不期而至的情况，导致程序中断运行的一种指令流。为了确保程序正常运行，在设计程序时必须考虑到各种异常情况，并正确的对异常进行处理。</p>
<p>运行时异常：表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常不会发生。</p>
<p>（编译时）受检查异常：Exception中除去运行时异常及其子类之外的异常。如果程序中出现此类异常，比如这个IOException，必须对该类异常进行处理，否则编译不通过。</p>
<p>Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明爬出未被捕获的运行时异常。</p>
<h4 id="49-列出一些你常见的运行时异常和编译时异常？"><a href="#49-列出一些你常见的运行时异常和编译时异常？" class="headerlink" title="49.列出一些你常见的运行时异常和编译时异常？"></a>49.列出一些你常见的运行时异常和编译时异常？</h4><p>运行时异常：ArithmeticException:算数异常</p>
<p>ClassCastException:类装换异常</p>
<p>IllegalArgumentException:非法参数异常</p>
<p>IndexOutOfBoundsException:数组下标越界</p>
<p>SecurityException:安全异常</p>
<p>编译时异常：FileNotFoundException：文件未找到异常</p>
<p>ClassNotFoundException：类未找到异常</p>
<p>IOException：IO操作异常</p>
<p>ParseException：时间格式化异常</p>
<h4 id="50-阐述final、finally、finalize的区别"><a href="#50-阐述final、finally、finalize的区别" class="headerlink" title="50.阐述final、finally、finalize的区别"></a>50.阐述final、finally、finalize的区别</h4><p>fianl：（修饰符）有三种用法，修饰属性常量类不能修改值，修饰方法方法不能重写，修饰类，类不能被继承</p>
<p>finally：通常放在try…catch的后面构造总是执行代码块，这意味着不管程序发生什么异常都要执行</p>
<p>finalize：方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他处理工作。</p>
<h4 id="51-类ExceptionA继承Exception，类ExceptionB继承ExceptionA"><a href="#51-类ExceptionA继承Exception，类ExceptionB继承ExceptionA" class="headerlink" title="51.类ExceptionA继承Exception，类ExceptionB继承ExceptionA"></a>51.类ExceptionA继承Exception，类ExceptionB继承ExceptionA</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExampleB</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>（ExampleA e）&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ExampleA&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请问执行此段代码的输出是什么？</p>
<p>抛出的是Exception，根据里氏代换原则，能使用父类型的地方一定能使用子类型，ExceptionB是ExceptionA的子类，所以抓取ExceptionA类型异常的catch能够抓取try块中抛出的ExceptionB类型异常。</p>
<h4 id="52-List、Set、Map是否继承自Collection接口"><a href="#52-List、Set、Map是否继承自Collection接口" class="headerlink" title="52.List、Set、Map是否继承自Collection接口"></a>52.List、Set、Map是否继承自Collection接口</h4><p>List和set是，map不是，</p>
<p>map：是键值对映射容器，映射关系可以是一对多或多对一</p>
<p>list：是线性结构容器，一般用于按数值索引访问元素的情形</p>
<p>set:是存储的零散元素不允许有重复的元素</p>
<h4 id="53-阐述ArrayList、Vector、LinkList的存储性能和特性。"><a href="#53-阐述ArrayList、Vector、LinkList的存储性能和特性。" class="headerlink" title="53.阐述ArrayList、Vector、LinkList的存储性能和特性。"></a>53.阐述ArrayList、Vector、LinkList的存储性能和特性。</h4><p>ArrayList和Vector都是使用数组方式存储数据，此数据元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素涉及数组元素移动等内存操作，所以索引数据快，插入数据慢，</p>
<p>由于Vector添加了，synchronized修饰，所以Vector是线程安全容器，但是性能上比ArrayList差，已经是Java中的遗留容器。</p>
<p>LinkList：使用了双向链表实现存储，按序号索引数据时需要进行向前向后的遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<h4 id="54-Collection和Collections的区别"><a href="#54-Collection和Collections的区别" class="headerlink" title="54.Collection和Collections的区别"></a>54.Collection和Collections的区别</h4><p>Collection是一个接口，它是Set、List等容器的父接口；</p>
<p>Collections是一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全等等。</p>
<h4 id="55-Java中HashMap和Hashtable的区别"><a href="#55-Java中HashMap和Hashtable的区别" class="headerlink" title="55.Java中HashMap和Hashtable的区别"></a>55.Java中HashMap和Hashtable的区别</h4><p>HashMap和HashTable都实现了Map接口</p>
<p>（1）HashMap允许空值，HashTable不允许空值</p>
<p>（2）HashMap是非同步的，HashTable是同步的</p>
<p>（3）HashMap中的迭代器是快速迭代器，HashTable中的枚举器不是</p>
<p>（4）在单线程使用下HashTable比HashMap慢很多</p>
<p>（5）HashMap不能保证Map的顺序会随着时间推移保持不变</p>
<p>HashMap的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;bai&quot;</span>,<span class="literal">null</span>);<span class="comment">//允许空值</span></span><br><span class="line">        map.put(<span class="string">&quot;li&quot;</span>,<span class="string">&quot;李&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;song&quot;</span>,<span class="string">&quot;宋&quot;</span>);</span><br><span class="line">        <span class="comment">//添加相同key的元素，值会覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;bai&quot;</span>,<span class="string">&quot;白&quot;</span>);</span><br><span class="line">        <span class="comment">//获取元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">li</span> <span class="operator">=</span> map.get(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        System.out.println(li);</span><br><span class="line">        <span class="comment">//删除元素</span></span><br><span class="line">        map.remove(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        <span class="comment">//获取集合大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> map.size();</span><br><span class="line">        System.out.println(size);</span><br><span class="line">        <span class="comment">//得到key的集合遍历</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String a:set) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;键名:&quot;</span>+a+<span class="string">&quot;键值:&quot;</span>+map.get(a));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接得到值集</span></span><br><span class="line">        Collection&lt;String&gt; value = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String val: value) &#123;</span><br><span class="line">            System.out.println(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到键值的集合</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; set1=map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String,String&gt; entry :set1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;键为:&quot;</span>+entry.getKey()+<span class="string">&quot;值为:&quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HashTable的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Hashtable&lt;String,String&gt; map =  <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">      <span class="comment">/*  map.put(&quot;bai&quot;,null);*/</span><span class="comment">//不允许空值</span></span><br><span class="line">        map.put(<span class="string">&quot;bai&quot;</span>,<span class="string">&quot;白的&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;li&quot;</span>,<span class="string">&quot;李&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;song&quot;</span>,<span class="string">&quot;宋&quot;</span>);</span><br><span class="line">        <span class="comment">//添加相同key的元素，值会覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;bai&quot;</span>,<span class="string">&quot;白&quot;</span>);</span><br><span class="line">        <span class="comment">//获取元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">li</span> <span class="operator">=</span> map.get(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        System.out.println(li);</span><br><span class="line">        <span class="comment">//删除元素</span></span><br><span class="line">        map.remove(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        <span class="comment">//获取集合大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> map.size();</span><br><span class="line">        System.out.println(size);</span><br><span class="line">        <span class="comment">//得到key的集合遍历</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String a:set) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;键名:&quot;</span>+a+<span class="string">&quot;键值:&quot;</span>+map.get(a));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接得到值集</span></span><br><span class="line">        Collection&lt;String&gt; value = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String val: value) &#123;</span><br><span class="line">            System.out.println(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到键值的集合</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; set1=map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String,String&gt; entry :set1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;键为:&quot;</span>+entry.getKey()+<span class="string">&quot;值为:&quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="56-List、Set、Map三个接口存储元素时，各有什么特长？"><a href="#56-List、Set、Map三个接口存储元素时，各有什么特长？" class="headerlink" title="56.List、Set、Map三个接口存储元素时，各有什么特长？"></a>56.List、Set、Map三个接口存储元素时，各有什么特长？</h4><p>List：是以指定元素来存储数据，可以有重复元素</p>
<p>Set：不能存放重复元素（用对象的equals来区分元素时否重复）</p>
<p>Map：键值对映射容器，Key-valu-pair,映射的关系可以是一对多或多对一</p>
<p>迭代器Iterator：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> okhttp3.internal.Internal;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; a =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a.add(<span class="number">1</span>);</span><br><span class="line">        a.add(<span class="number">2</span>);</span><br><span class="line">        a.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//将List集合放入迭代器中</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator  = a.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;<span class="comment">//判断是否为空,空的话是会返回false的</span></span><br><span class="line">            <span class="type">int</span> n=iterator.next();</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="57-TreeMap和TreeSet在在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#57-TreeMap和TreeSet在在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="57.TreeMap和TreeSet在在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>57.TreeMap和TreeSet在在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h4><p>TreeSet：要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素大小。</p>
<p>TreeMap：要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序</p>
<p>Collection工具类的sort方法有两种重载的形式</p>
<p>（1）要求传入的待排序容器中存放的对象比较实现Comparable接口可以实现元素的比较</p>
<p>（2）不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型，相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用</p>
<p>TreeMap:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个有序对象集合</span></span><br><span class="line">        <span class="comment">//自然排序</span></span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        treeMap.put(<span class="number">2</span>,<span class="string">&quot;鸡巴&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="number">1</span>,<span class="string">&quot;鸡巴&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="number">4</span>,<span class="string">&quot;鸡巴&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="number">3</span>,<span class="string">&quot;鸡巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">        treeMap.forEach((k,v)-&gt;</span><br><span class="line">            System.out.println(<span class="string">&quot;键:&quot;</span>+k+<span class="string">&quot;值:&quot;</span>+v)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订制排序</span></span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap2 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">               <span class="comment">/* o1&gt;o2?1:(o1&lt;o2)?-1:0*/</span>  <span class="comment">//升序 o1-o2</span></span><br><span class="line">                <span class="keyword">return</span> o1&gt;o2?-<span class="number">1</span>:(o1&lt;o2)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//降序o2-o1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap2.put(<span class="number">2</span>,<span class="string">&quot;鸡巴&quot;</span>);</span><br><span class="line">        treeMap2.put(<span class="number">1</span>,<span class="string">&quot;鸡巴&quot;</span>);</span><br><span class="line">        treeMap2.put(<span class="number">4</span>,<span class="string">&quot;鸡巴&quot;</span>);</span><br><span class="line">        treeMap2.put(<span class="number">3</span>,<span class="string">&quot;鸡巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">        treeMap2.forEach((k,v)-&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;键:&quot;</span>+k+<span class="string">&quot;值:&quot;</span>+v)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TreeSet:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个有序对象集合</span></span><br><span class="line">        <span class="comment">//自然排序</span></span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="number">2</span>);</span><br><span class="line">        treeSet.add(<span class="number">1</span>);</span><br><span class="line">        treeSet.add(<span class="number">4</span>);</span><br><span class="line">        treeSet.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        treeSet.forEach(v -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;值&quot;</span> + v)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到首个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;首个元素&quot;</span>+treeSet.first().intValue());</span><br><span class="line">        <span class="comment">//lower返回集合中小于给定元素的最大元素，没有就返回null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小于（2）的最大元素&quot;</span>+treeSet.lower(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//移除并返回集合中的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;移除并返回集合中的第一个元素:&quot;</span>+treeSet.pollFirst());</span><br><span class="line">        <span class="keyword">for</span> (Integer a :treeSet) &#123;</span><br><span class="line">            System.out.println(a.intValue());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sort()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; arrayList= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       arrayList.add(<span class="number">1</span>);</span><br><span class="line">       arrayList.add(<span class="number">2</span>);</span><br><span class="line">       arrayList.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       arrayList.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> o2-o1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">        arrayList.forEach(v-&gt; System.out.println(v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="58-Thread类中的sleep-方法和对象的wait方法都可以让线程暂停执行，他们有什么区别"><a href="#58-Thread类中的sleep-方法和对象的wait方法都可以让线程暂停执行，他们有什么区别" class="headerlink" title="58.Thread类中的sleep()方法和对象的wait方法都可以让线程暂停执行，他们有什么区别"></a>58.Thread类中的sleep()方法和对象的wait方法都可以让线程暂停执行，他们有什么区别</h4><p>sleep是指让一个线程进入休眠状态，没有释放对象的锁，等到休眠期结束就可以进入就绪状态</p>
<p>wait让一个线程进入等待状态，释放了对象的锁，需要用notfiy方法或notifyALL方法才能唤醒等待池中的方法进入等锁池，重新获取对象的锁后进入就绪状态</p>
<h4 id="59-线程的sleep-方法和yield-方法有什么区别？"><a href="#59-线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="59.线程的sleep()方法和yield()方法有什么区别？"></a>59.线程的sleep()方法和yield()方法有什么区别？</h4><p>（1）sleep方法给其他线程运行机会时不会考虑线程的优先级，因此会给低优先级的线程以运行的机会；</p>
<p>​	yield方法只会给相同优先级或更高优先级的线程以运行机会</p>
<p>（2）线程执行sleep方法后转入阻塞状态，而执行yield方法后转入就绪状态</p>
<p>（3）sleep方法声明抛出InterruptedException，而yield方法没有声明任何异常</p>
<p>（4）sleep方法比yield方法具有更好的可移植性</p>
<h4 id="60-sleep方法和wait方法有什么区别？"><a href="#60-sleep方法和wait方法有什么区别？" class="headerlink" title="60.sleep方法和wait方法有什么区别？"></a>60.sleep方法和wait方法有什么区别？</h4><p>sleep()方法是一个静态方法，也就是说他只对当前对象 有效，通过t.sleep()让t对象进入sleep，这样的做法是错误的，它只会是使当前线程被sleep 而不是t线程。</p>
<p>wait属于Object的成员方法，一旦一个对象调用了wait方法，必须要采用notify()和notifyAll()方法唤醒该进程;如果线程拥有某个或某些对象的同步锁，那么在调用了wait()后，这个线程就会释放它持有的所有同步资源，而不限于这个被调用了wait()方法的对象。wait()方法也同样会在wait的过程中有可能被其他对象调用interrupt()方法而产生  </p>
<h4 id="61-当一个线程进入一个对象的synchronized方法A之后，其他线程是否可进入此对象的synchronized方法B"><a href="#61-当一个线程进入一个对象的synchronized方法A之后，其他线程是否可进入此对象的synchronized方法B" class="headerlink" title="61.当一个线程进入一个对象的synchronized方法A之后，其他线程是否可进入此对象的synchronized方法B?"></a>61.当一个线程进入一个对象的synchronized方法A之后，其他线程是否可进入此对象的synchronized方法B?</h4><p>不能，因为synchronized修饰发是线程安全修饰符，也就是同步的，一个线程进去后，其他线程只能访问该对象的非同步方法，同步方法则不能进入，因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走了，那么试图进入B方法的线程只能在等锁池中等待对象的锁。</p>
<h4 id="62-请说出线程同步以及线程调度相关的方法。"><a href="#62-请说出线程同步以及线程调度相关的方法。" class="headerlink" title="62.请说出线程同步以及线程调度相关的方法。"></a>62.请说出线程同步以及线程调度相关的方法。</h4><p>wait()：使一个线程进入等待（阻塞）状态，释放了对象的锁，需要notify或nottifyAll来唤醒进入等锁池</p>
<p>sleep()：使一个正在运行的线程进入睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常</p>
<p>notify()：唤醒一个处于等待（阻塞）状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM（Java VM虚拟机）来确定唤醒哪个线程</p>
<p>notifyAll()：唤醒所有处于等待状态的线程，该方法并不是讲对象的锁给所有线程，而是让他们竞争，只有获得对象的锁的线程才能进入就绪状态</p>
<h4 id="63-编写多线程的方式有几种？"><a href="#63-编写多线程的方式有几种？" class="headerlink" title="63.编写多线程的方式有几种？"></a>63.编写多线程的方式有几种？</h4><p>1.继承Thread类，并重写run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.当一个类继承了Thread类，该类就可以当成线程使用</span></span><br><span class="line"><span class="comment">//2.我们会重写run方法，写上自己的业务代码</span></span><br><span class="line"><span class="comment">//3.run Thread 类 实现了Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; <span class="comment">//重写run方法，写上自己的业务逻辑</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//无限循环</span></span><br><span class="line">        <span class="keyword">while</span> (a&lt;<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">//该线程每隔一秒钟。在控制台输出“喵喵，我是小喵咪”</span></span><br><span class="line">            System.out.println(<span class="string">&quot;喵喵我是小喵咪&quot;</span>+(++a));</span><br><span class="line">            <span class="comment">//让该线程休眠1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">/* if(a==80)&#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Text</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">        text.start();</span><br><span class="line">        <span class="comment">//这是主线程和子线程是交替执行..</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程 i=&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Niubi</span> <span class="variable">niubi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Niubi</span>();</span><br><span class="line">        <span class="comment">//模拟了代理模式，此行代码和Thread thread = new Thread(niubi)等价</span></span><br><span class="line">        <span class="type">ThreadProxy</span> <span class="variable">threadProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadProxy</span>(niubi);</span><br><span class="line">        threadProxy.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Niubi</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老虎嗷嗷叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程代理模式，模拟了一个最简单的Thread</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadProxy</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//属性，类型是Runable</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target!=<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            target.run();<span class="comment">//动态绑定Niubi</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProxy</span><span class="params">(Runnable target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target =target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span> <span class="params">()</span>&#123;</span><br><span class="line">        start0();<span class="comment">//这个方法真正实现多线程方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.从Java5以后创建线程还有第三种方式，实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> upperBounds;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> upperBounds)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.upperBounds = upperBounds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= upperBounds; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(service.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>((<span class="type">int</span>) (Math.random() * <span class="number">100</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Integer&gt; future : list) &#123;</span><br><span class="line">            <span class="comment">// while(!future.isDone()) ;</span></span><br><span class="line">            sum += future.get();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="64-synchronized关键字的用法？"><a href="#64-synchronized关键字的用法？" class="headerlink" title="64.synchronized关键字的用法？"></a>64.synchronized关键字的用法？</h4><p>synchronized可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized（对象）定义同步代码块，或者在声明方法时讲synchronized作为方法的修饰符。</p>
<h4 id="65-举例说明同步和异步"><a href="#65-举例说明同步和异步" class="headerlink" title="65.举例说明同步和异步"></a>65.举例说明同步和异步</h4><p>同步：就是指阻塞式操作</p>
<p>异步：就是非阻塞式操作</p>
<h4 id="66-启动一个线程是调用run（）还是start（）？"><a href="#66-启动一个线程是调用run（）还是start（）？" class="headerlink" title="66.启动一个线程是调用run（）还是start（）？"></a>66.启动一个线程是调用run（）还是start（）？</h4><p>是start（），因为单独调用run并不会开启一个线程，启动的线程还是你main方法的，是得调用strat，在对象里面start里面写入了start0()方法在这个方法里面调用了run()，也就是进行了一个回调操作。</p>
<h4 id="67-什么是线程池"><a href="#67-什么是线程池" class="headerlink" title="67.什么是线程池"></a>67.什么是线程池</h4><p>在面向对象编程的时候，创建线程和销毁线程都是非常耗费时间的，所以就诞生了线程池，你需要线程的时候不用手动去创建，而是直接去线程池里面去拿这个线程，销毁操作也不用做了，用完直接放回到这个线程池里面，大大减少了我们创建线程和销毁线程的时间。</p>
<p>生成常用的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</span><br><span class="line"></span><br><span class="line">newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</span><br><span class="line"></span><br><span class="line">newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（<span class="number">60</span>秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</span><br><span class="line"></span><br><span class="line">newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</span><br><span class="line"></span><br><span class="line">newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</span><br><span class="line">如果希望在服务器上使用线程池，强烈建议使用newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="68-线程的基本状态以及状态之间的关系"><a href="#68-线程的基本状态以及状态之间的关系" class="headerlink" title="68.线程的基本状态以及状态之间的关系"></a>68.线程的基本状态以及状态之间的关系</h4><p><strong>说明：</strong>其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I&#x2F;O中断。</p>
<p><strong>状态</strong>：</p>
<p>基本状态：就绪状态，阻塞状态，运行状态</p>
<p>就绪状态：表示线程具备运行的所有条件，逻辑上可以运行，在等待处理机</p>
<p>运行状态：指线程占有处理机正在运行</p>
<p>阻塞状态：指线程在等待一个事件（如信号量），逻辑上不可执行</p>
<p>细分的线程状态：</p>
<p><strong>1.</strong> <strong>新建</strong></p>
<p>new语句创建的线程对象处于新建状态，此时它和其他java对象一样，仅被分配了内存。</p>
<p><strong>2.</strong> <strong>等待</strong></p>
<p>当线程在new之后，并且在调用start方法前，线程处于等待状态。</p>
<p><strong>3.</strong> <strong>就绪</strong></p>
<p>当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态。处于这个状态的线程位于Java虚拟机的可运行池中，等待cpu的使用权。</p>
<p><strong>4.</strong> <strong>运行状态</strong></p>
<p>处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任何时刻只会有一个线程处于这个状态。</p>
<p>只有处于就绪状态的线程才有机会转到运行状态。</p>
<p><strong>5.</strong> <strong>阻塞状态</strong></p>
<p>阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，它才会有机会获得运行状态。</p>
<p>阻塞状态分为三种:</p>
<p>1.等待阻塞:运行的线程执行wait（）方法，JVM会把该线程放入等待池中。</p>
<p>2.同步阻塞:运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中。</p>
<p>3.其他阻塞:运行的线程执行Sleep（）方法，或者发出I&#x2F;O请求时，JVM会把线程设为阻塞状态。当Sleep（）状态超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</p>
<p><strong>6.</strong> <strong>死亡状态</strong></p>
<p>当线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，此时就进入死亡状态，该线程结束生命周期。</p>
<h4 id="69-简述synchronized和-java-util-concurrent-locks-Lock"><a href="#69-简述synchronized和-java-util-concurrent-locks-Lock" class="headerlink" title="69.简述synchronized和 java.util.concurrent.locks.Lock"></a>69.简述synchronized和 java.util.concurrent.locks.Lock</h4><p>Lock是Java5以后引入的新的API，和关键字synchronized相比主要的</p>
<p>相同点：</p>
<p>Lock能完成synchronized所实现的所有功能</p>
<p>不同点：</p>
<p>Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。</p>
<p>synchronized会自动释放锁，而lock要求程序员手工释放，并且最好是在finally块中释放（这是释放资源的最好地方）</p>
<h4 id="70-Java中如何实现序列化，有什么意义？"><a href="#70-Java中如何实现序列化，有什么意义？" class="headerlink" title="70.Java中如何实现序列化，有什么意义？"></a>70.Java中如何实现序列化，有什么意义？</h4><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。</p>
<p>原因（意义）：</p>
<p>（1）网络传输：网络传输的数据都必须是二进制数据，但是在Java中都是对象，是没有办法在网络中传输的，所以需要对Java对象进行序列化，并且要求这个序列化是可逆的，也就是说要可以进行反序列化，否则人家都不知道你传递的是啥意思。</p>
<p>（2）对象持久化，即将在内存中的对象状态保存到文件或者数据库中</p>
<p>（3）实现分布式对象，如RMI（远程方法调用）要利用对象序列化运行远程主机上的服务，就像在本机上运行对象时一样</p>
<p>Java原生序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hdax.dm.user.dto.LinkUserDto;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//如果父类没有实现Serializable的话，调用父类方法字段则不会序列化</span></span><br><span class="line">    <span class="comment">//static修饰的也无法序列化</span></span><br><span class="line">    <span class="comment">//transient关键字，也无法序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//实现序列化的方式</span></span><br><span class="line">        <span class="comment">//序列化使用的ObjectOutputStream类</span></span><br><span class="line">        <span class="type">Text</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">        text.setAge(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;niubi&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(text);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现反序列化的方式</span></span><br><span class="line">        <span class="comment">//反序列化使用的是ObjectInputStream类的readObject方法，readObject函数返回的是Object类型的对象,所以需要强制类型转换</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;niubi&quot;</span>));</span><br><span class="line">        <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> (Text) objectInputStream.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;被序列化后反序列化的数据:&quot;</span>+text1.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：效率较低，序列化后的流数据比较大</p>
<p>2.使用第三方的序列化方式：如JSON、Hessian等</p>
<h4 id="71-Java中有几种类型的流？"><a href="#71-Java中有几种类型的流？" class="headerlink" title="71.Java中有几种类型的流？"></a>71.Java中有几种类型的流？</h4><p>（1）字节流：字节流继承于InputStream，OutputStream,</p>
<p>（2）字符流：字符流继承于Reader、Writer</p>
<p>在Java中还有许多其他的流，主要是为了提高性能和使用方便。</p>
<img src="/url=https:/s1.ax1x.com/2022/09/16/xS3iuR.png" class="" title="title&#x3D;">

<h3 id="字节流具体使用"><a href="#字节流具体使用" class="headerlink" title="字节流具体使用"></a>字节流具体使用</h3><p><strong>写数据实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator+<span class="string">&quot;test.txt&quot;</span>);<span class="comment">//File.separator的作用相当于 &#x27; \ &#x27;</span></span><br><span class="line">        OutputStream out=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);<span class="comment">//如果文件不存在会自动创建</span></span><br><span class="line">        String str=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] b=str.getBytes();</span><br><span class="line">        out.write(b);<span class="comment">//因为是字节流，所以要转化成字节数组进行输出</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以一个字节一个字节进行输出，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);<span class="comment">//如果文件不存在会自动创建</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] b = str.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            out.write(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上输出只会进行覆盖，如果要追加的话，请看FileOutputStream类的另一个构造方法：</p>
<p>在构造方法中，如果将append的值设置为true，则表示在文件的末尾追加内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f, <span class="literal">true</span>);<span class="comment">//追加内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;\r\nHello World&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] b = str.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            out.write(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读文件实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        InputStream in=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">        <span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</span><br><span class="line">            b[i]=(<span class="type">byte</span>) in.read();</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但以上情况只适合知道输入文件的大小，不知道的话用如下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        InputStream in=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">        <span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((temp=in.read())!=-<span class="number">1</span>)&#123;<span class="comment">//-1为文件读完的标志</span></span><br><span class="line">            b[len]=(<span class="type">byte</span>) temp;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,len));<span class="comment">//b是类型也就是byte,0是从第几个开始索引，len是长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流具体使用"><a href="#字符流具体使用" class="headerlink" title="字符流具体使用"></a>字符流具体使用</h3><p>字节输出流：Writer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f);<span class="comment">//追加的话还是加上true，要不然就是覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello 字符流&quot;</span>;</span><br><span class="line">        out.write(str);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符输入流：Reader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator+<span class="string">&quot;王旭瑞.txt&quot;</span>);</span><br><span class="line">        Reader input=<span class="keyword">new</span> <span class="title class_">FileReader</span>(f);</span><br><span class="line">        <span class="type">char</span>[] c=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=input.read(c);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(c,<span class="number">0</span>,len));<span class="comment">//c是类型也就是char,0是从第几个开始索引，len是长度</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="72-写一个方法，输入一个文件名和一个字符串，统计这个字符串在文件中出现的次数。"><a href="#72-写一个方法，输入一个文件名和一个字符串，统计这个字符串在文件中出现的次数。" class="headerlink" title="72.写一个方法，输入一个文件名和一个字符串，统计这个字符串在文件中出现的次数。"></a>72.写一个方法，输入一个文件名和一个字符串，统计这个字符串在文件中出现的次数。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyUtil</span> &#123;</span><br><span class="line">    <span class="comment">// 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyUtil</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计给定文件中给定字符串的出现次数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename  文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串在文件中出现的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countWordInFile</span><span class="params">(String filename, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(filename)) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr)) &#123;</span><br><span class="line">        <span class="comment">//BufferedReader从字符输入流中读取文本，缓冲字符，以便高效读取字符、数组和行。</span></span><br><span class="line">        <span class="comment">//可以指定缓冲区大小，也可以使用默认大小。对于大多数用途，默认值足够大。</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//将你查文件里面文本信息赋值进去的时候他就不会为空就会走进去循环</span></span><br><span class="line">                <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置索引默认为-1</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//如果你查到的文本长度&gt;你要查的文本长度并且输入的字符串和你查到的字符串做比较，如果没					有查到的话会返回-1则就进不去</span></span><br><span class="line">                    <span class="keyword">while</span> (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//进去之后要查的文本出现的次数+1</span></span><br><span class="line">                        counter++;</span><br><span class="line">                        <span class="comment">//截取这行不匹配条件的字符</span></span><br><span class="line">                        line = line.substring(index + word.length());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="73-如何用Java代码列出一个目录下所有文件"><a href="#73-如何用Java代码列出一个目录下所有文件" class="headerlink" title="73.如何用Java代码列出一个目录下所有文件"></a>73.如何用Java代码列出一个目录下所有文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span>+File.separator+<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f.isDirectory()) &#123;<span class="comment">//如果是目录不是文件就进去</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件夹:&quot;</span> + f.getPath());</span><br><span class="line">            File[] listFiles = f.listFiles();<span class="comment">//获取当前路径下的所有文件和目录,返回File对象数组</span></span><br><span class="line">            <span class="keyword">for</span>(File file : listFiles) &#123;<span class="comment">//将目录内的内容对象化并遍历</span></span><br><span class="line">                <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                    System.out.println(file.getName());<span class="comment">//输出文件名称</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="74-用Java的套接字编程实现一个多线程的回显（echo）服务器"><a href="#74-用Java的套接字编程实现一个多线程的回显（echo）服务器" class="headerlink" title="74.用Java的套接字编程实现一个多线程的回显（echo）服务器"></a>74.用Java的套接字编程实现一个多线程的回显（echo）服务器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ECHO_SERVER_PORT</span> <span class="operator">=</span> <span class="number">6789</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(ECHO_SERVER_PORT)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已经启动...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientHandler</span>(client)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Socket client;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClientHandler</span><span class="params">(Socket client)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.client = client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream()));</span><br><span class="line">                    <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(client.getOutputStream())) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;收到&quot;</span> + client.getInetAddress() + <span class="string">&quot;发送的: &quot;</span> + msg);</span><br><span class="line">                pw.println(msg);</span><br><span class="line">                pw.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：上面的代码使用了Java <span class="number">7</span>的TWR语法，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在<span class="keyword">try</span>结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的<span class="keyword">finally</span>代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户I/O操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。</span><br><span class="line">下面是一段回显客户端测试代码：</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6789</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入内容: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(client.getOutputStream());</span><br><span class="line">        pw.println(msg);</span><br><span class="line">        pw.flush();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream()));</span><br><span class="line">        System.out.println(br.readLine());</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServerNIO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ECHO_SERVER_PORT</span> <span class="operator">=</span> <span class="number">6789</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ECHO_SERVER_TIMEOUT</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// 多路复用选择器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverChannel = ServerSocketChannel.open();</span><br><span class="line">            buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            serverChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(ECHO_SERVER_PORT));</span><br><span class="line">            serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (selector.select(ECHO_SERVER_TIMEOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                        it.remove();</span><br><span class="line">                        handleKey(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleKey</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                channel = serverChannel.accept();</span><br><span class="line">                channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                channel = (SocketChannel) key.channel();</span><br><span class="line">                buffer.clear();</span><br><span class="line">                <span class="keyword">if</span> (channel.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> CharsetHelper.decode(buffer);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> charBuffer.toString();</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到&quot;</span> + channel.getRemoteAddress() + <span class="string">&quot;的消息：&quot;</span> + msg);</span><br><span class="line">                    channel.write(CharsetHelper.encode(CharBuffer.wrap(msg)));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharacterCodingException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CharsetHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UTF_8</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CharsetEncoder</span> <span class="variable">encoder</span> <span class="operator">=</span> Charset.forName(UTF_8).newEncoder();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CharsetDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> Charset.forName(UTF_8).newDecoder();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharsetHelper</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">encode</span><span class="params">(CharBuffer in)</span> <span class="keyword">throws</span> CharacterCodingException&#123;</span><br><span class="line">        <span class="keyword">return</span> encoder.encode(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CharBuffer <span class="title function_">decode</span><span class="params">(ByteBuffer in)</span> <span class="keyword">throws</span> CharacterCodingException&#123;</span><br><span class="line">        <span class="keyword">return</span> decoder.decode(in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="75-XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"><a href="#75-XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？" class="headerlink" title="75.XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"></a>75.XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</h4><p>XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，Document<br>Object Model）、SAX（Simple API<br>for XML）和StAX（Java 6中引入的新的解析XML的方式，Streaming API for XML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p>
<h4 id="76-你在项目中哪些地方用到了XML？"><a href="#76-你在项目中哪些地方用到了XML？" class="headerlink" title="76.你在项目中哪些地方用到了XML？"></a>76.你在项目中哪些地方用到了XML？</h4><p>XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理，XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http:/www.dom4j.org">dom4j</a>作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。</p>
<h4 id="77-阐述JDBC操作数据库的步骤？"><a href="#77-阐述JDBC操作数据库的步骤？" class="headerlink" title="77.阐述JDBC操作数据库的步骤？"></a>77.阐述JDBC操作数据库的步骤？</h4><p>（1）加载驱动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>（2）创建连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Conection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConection(<span class="string">&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>（3）创建语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> con.prepareStatement(<span class="string">&quot;select * from emp where sql between?and?&quot;</span>);ps.setInt(<span class="number">1</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>（4）执行语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br></pre></td></tr></table></figure>

<p>（5）处理结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(rs.getInt(<span class="string">&quot;empno&quot;</span>)+<span class="string">&quot;-&quot;</span>+rs.getString(<span class="string">&quot;ename&quot;</span>)))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（6）关闭资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               con.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、在关闭Connection。上面的代码只关闭了Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在JDBC 4.0中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p>
<h4 id="78-Statement和preparedStatement有什么区别？哪个性能更好？"><a href="#78-Statement和preparedStatement有什么区别？哪个性能更好？" class="headerlink" title="78.Statement和preparedStatement有什么区别？哪个性能更好？"></a>78.Statement和preparedStatement有什么区别？哪个性能更好？</h4><p>与Statement相比：</p>
<p>（1）PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；</p>
<p>（2）PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；</p>
<p>（3）当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p>
<h4 id="79-使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"><a href="#79-使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？" class="headerlink" title="79.使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"></a>79.使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</h4><p>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。</p>
<h4 id="80-在进行数据库编程时，连接池有什么作用？"><a href="#80-在进行数据库编程时，连接池有什么作用？" class="headerlink" title="80.在进行数据库编程时，连接池有什么作用？"></a>80.在进行数据库编程时，连接池有什么作用？</h4><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http:/sourceforge.net/projects/c3p0/">C3P0</a>、<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http:/proxool.sourceforge.net">Proxool</a>、<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http:/commons.apache.org/proper/commons-dbcp/">DBCP</a>、<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https:/github.com/wwadge/bonecp">BoneCP</a>、<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https:/github.com/alibaba/druid">Druid</a>等。</p>
<h4 id="81-什么是Dao模式？"><a href="#81-什么是Dao模式？" class="headerlink" title="81.什么是Dao模式？"></a>81.什么是Dao模式？</h4><p>Dao顾名思义就是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据库访问操作。</p>
<p>在实际开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事物方法。</p>
<p>在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，</p>
<p>（1）Data Accessor（数据访问器）</p>
<p>（2）Data Object（数据对象）</p>
<p>前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h4 id="82-事物的ACID是什么？"><a href="#82-事物的ACID是什么？" class="headerlink" title="82.事物的ACID是什么？"></a>82.事物的ACID是什么？</h4><p>（1）原子性（atomic）：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事物的失败；</p>
<p>（2）一致性（Consistent）：事物结束后系统状态是一致的</p>
<p>（3）隔离性（Isolated）：并发执行的事务彼此无法看到对方的中间状态</p>
<p>（4）持久化（Durable）：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p>
<h4 id="83-JDBC中如何进行事务处理？"><a href="#83-JDBC中如何进行事务处理？" class="headerlink" title="83.JDBC中如何进行事务处理？"></a>83.JDBC中如何进行事务处理？</h4><p>Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p>
<h4 id="84-JDBC能否处理Blod和CLod？"><a href="#84-JDBC能否处理Blod和CLod？" class="headerlink" title="84.JDBC能否处理Blod和CLod？"></a>84.JDBC能否处理Blod和CLod？</h4><p>Blod是指二进制大对象，而Clod是指大字符对象，因此其中Blod是为存储大的二进制数据而设计的。而Clod是为存储大文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。下面的代码展示了如何使用JDBC操作LOB：下面以<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http:/lib.csdn.net/base/mysql">MySQL</a>数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo）</p>
<h4 id="85-简述正则表达式及其用途。"><a href="#85-简述正则表达式及其用途。" class="headerlink" title="85.简述正则表达式及其用途。"></a>85.简述正则表达式及其用途。</h4><p>在编写处理字符串的程序，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<h4 id="86-Java中是如何支持正则表达式操作的？"><a href="#86-Java中是如何支持正则表达式操作的？" class="headerlink" title="86.Java中是如何支持正则表达式操作的？"></a>86.Java中是如何支持正则表达式操作的？</h4><p>java中的String	类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。</p>
<h4 id="87-获得一个类的类对象有哪些方式？"><a href="#87-获得一个类的类对象有哪些方式？" class="headerlink" title="87.获得一个类的类对象有哪些方式？"></a>87.获得一个类的类对象有哪些方式？</h4><p>（1）类型.class,例如String.class</p>
<p>（2）对象.class,例如”hellow”.getClass()；</p>
<p>（3）Class.forName(),例如Class.forName(“java.long.String”)</p>
<h4 id="88-如何通过反射创建对象"><a href="#88-如何通过反射创建对象" class="headerlink" title="88.如何通过反射创建对象"></a>88.如何通过反射创建对象</h4><p>（1）通过这个类对象调用newInstance()方法，例如：String.class.newInstance()</p>
<p>（2）通过类对象的getConstructor()或者getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”)</p>
<h4 id="89-如何通过反射获取和设置对象私有字段的值？"><a href="#89-如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="89.如何通过反射获取和设置对象私有字段的值？"></a>89.如何通过反射获取和设置对象私有字段的值？</h4><p>可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get&#x2F;set方法来获取&#x2F;设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射工具类</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ReflectionUtil</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射取对象指定字段(属性)的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName 字段的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果取不到对象指定字段的值则抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字段的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getValue</span><span class="params">(Object target, String fieldName)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        String[] fs = fieldName.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fs.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> clazz.getDeclaredField(fs[i]);</span><br><span class="line">                f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                target = f.get(target);</span><br><span class="line">                clazz = target.getClass();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> clazz.getDeclaredField(fs[fs.length - <span class="number">1</span>]);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> f.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射给对象的指定字段赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName 字段的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object target, String fieldName, Object value)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        String[] fs = fieldName.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fs.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> clazz.getDeclaredField(fs[i]);</span><br><span class="line">                f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> f.get(target);</span><br><span class="line">                <span class="keyword">if</span>(val == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Constructor&lt;?&gt; c = f.getType().getDeclaredConstructor();</span><br><span class="line">                    c.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    val = c.newInstance();</span><br><span class="line">                    f.set(target, val);</span><br><span class="line">                &#125;</span><br><span class="line">                target = val;</span><br><span class="line">                clazz = target.getClass();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> clazz.getDeclaredField(fs[fs.length - <span class="number">1</span>]);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            f.set(target, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="90-如何通过反射调用对象的方法？"><a href="#90-如何通过反射调用对象的方法？" class="headerlink" title="90.如何通过反射调用对象的方法？"></a>90.如何通过反射调用对象的方法？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MethodInvokeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> str.getClass().getMethod(<span class="string">&quot;toUpperCase&quot;</span>);</span><br><span class="line">        System.out.println(m.invoke(str));  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="91-简述一下你了解的设计模式"><a href="#91-简述一下你了解的设计模式" class="headerlink" title="91.简述一下你了解的设计模式"></a>91.简述一下你了解的设计模式</h4><p>所谓设计模式就是一套被反复使用的代码设计经验的总结。使用这个设计模式的话，是为了可重用代码的、让代码更容易理解、保证代码的可靠性</p>
<p>（1）工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。</p>
<p>（2）代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。</p>
<p>（3）适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。</p>
<p>（4）模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。</p>
<h4 id="92-什么是单例模式？用Java写一个单例模式"><a href="#92-什么是单例模式？用Java写一个单例模式" class="headerlink" title="92.什么是单例模式？用Java写一个单例模式"></a>92.什么是单例模式？用Java写一个单例模式</h4><p>单例模式的话就是java中最简单的设计模式之一。这种模式的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>注意：</p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p>优点：</p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p>缺点：</p>
<p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：</p>
<ul>
<li>1、要求生产唯一序列号。 </li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I&#x2F;O 与数据库的连接等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) instance ＝ <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="93-什么是工厂模式？"><a href="#93-什么是工厂模式？" class="headerlink" title="93.什么是工厂模式？"></a>93.什么是工厂模式？</h4><p>工厂模式就是设计模式中最常用的设计模式之一。这种模式的设计模式是创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p><strong>优点：</strong> </p>
<p>1、一个调用者想创建一个对象，只要知道其名称就可以了。</p>
<p>2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p>
<p>3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p><strong>缺点：</strong></p>
<p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p><strong>使用场景：</strong> </p>
<p>1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</p>
<p>2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</p>
<p>3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 </p>
<h4 id="94-什么是UML？"><a href="#94-什么是UML？" class="headerlink" title="94.什么是UML？"></a>94.什么是UML？</h4><p>UML是统一建模语言（Unified<br>Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。</p>
<h4 id="95-UML中有哪些常用的图？"><a href="#95-UML中有哪些常用的图？" class="headerlink" title="95.UML中有哪些常用的图？"></a>95.UML中有哪些常用的图？</h4><p>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</p>
<h4 id="96-什么是ORM？"><a href="#96-什么是ORM？" class="headerlink" title="96.什么是ORM？"></a>96.什么是ORM？</h4><p>对象关系映射（Object-Relational 	Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>（1）总结</p>
<p>Spirng:是一个轻量级的IOC和AOP框架,这个IOC呢就是这个控制反转，就是原本要你手动创建对象的工作，现在交给这个Spring容器来进行，你想用就去容器里面拿，不用手动的去创建，也就是一个控制权的反转吧。Dl依赖注入：应用程序运行依赖的资源由Spring为其提供，资源进入应用程序的方式称为注入，ioC和Dl是同一件事站在不同角度看待问题，AOP就是面向切面编程，在不惊动原始设计的基础上为其进行功能增强，这个增强其实跟代理相似，就是在不改动原有代码的前提下，想给谁添加功能就给谁添加。</p>
<p>AOP代表的是一个横向的关系，剖开对象的内部，并且把影响多个类的共同行为抽取出来，作为公共模块（叫做切面Aspect），然后再通过织入的方式把这个切面放进去。<br>就是能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，<br>便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>（1）总结</p>
<p>他是spring的一个模块，无需中间整合层来整合，它和Struts2属于表现层的框架，MVC是一种很流行的框架，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>
<p>（2）优点</p>
<p>1）它是基于组件技术的。全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成.</p>
<p>2）不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)</p>
<p>3）可以任意使用各种视图技术,而不仅仅局限于JSP</p>
<p>4）支持各种请求资源的映射策略</p>
<p>5）它应是易于扩展的</p>
<p>（3）SpringMVC的工作原理：</p>
<p>1）浏览器发送指定请求给DispatcherServlet（前端控制器）,他会委托其他模块进行真正的业务处理和数据处理</p>
<p>2）DispatcherSevlet（前端控制器）会查找到HandleMapping（处理器映射），根据浏览器请求找到对应的Controller，并将请求交给目标Controller</p>
<p>3）目标Controller处理完业务之后，返回一个ModelAndView（模型和视图）给DisparcherServlet（前端控制器）</p>
<p>4）DispatcherServlet通过ViewResolver（视图解析器）找到对应的视图对象View</p>
<p>5）视图对象View负责渲染，并返回到浏览器</p>
<p>（4）常用注解</p>
<p>1）Controller：将一个类标注为控制层</p>
<p>2）RequestMapping：建立请求URL和处理方法之间的对应关系</p>
<p>3）Autowired：spring可以自动帮你把bean里面引用的对象的setter&#x2F;getter方法省略，自动帮你set&#x2F;get</p>
<p>4）RequestBody：获取请求体的内容</p>
<p>5）ResponseBody：ResponseBody注解通常使用在控制层的方法上，用于将Controller的方法返回的对象，通过springmvc提供的<code>HttpMessageConverter</code>接口转换为指定格式的数据如：json、xml等，通过Response响应给客户端。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>（1）总结</p>
<p>mybatis是一个半ROM（对象关系映射）框架，它内部封装了JDBC，开发的时候只需要关注SQL语句本身，不用去处理加载驱动、创建连接等繁杂过程。程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高</p>
<p>（2）mybatis一、二级缓存</p>
<p>1）一级缓存的作用域默认是一个SqlSession。Mybatis默认会开启一级缓存。也就是在开启事物的时候多次进行查询，第一次去数据库查询并且写到缓存中，第二次以后都是直接去缓存中取。使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个SqlSession对象表示一次数据库会话，在对数据库的一次会话中， 有可能会反复地执行完全相同的查询语句，每一次查询都会去查一次数据库,为了减少资源浪费。</p>
<p>2）二级缓存默认是关闭的，一级缓存因为只能在同一个SqlSession中共享，所以会存在一个问题，在分布式或者多线程的环境下，不同会话之间对于相同的数据可能会产生不同的结果，因为跨会话修改了数据是不能互相感知的，所以就有可能存在脏数据的问题，正因为一级缓存存在这种不足，需要一种作用域更大的缓存，这就是二级缓存。</p>
<p>（3）mybatis-plus</p>
<p>Mybatis-plus是一个MyBatis的增强工具，在Mybatis上只做增强不做改变，为简化开发、提高效率而生</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>（1）总结</p>
<p>springboot是一个快速开发框架，能够帮助我们快速的整合各种第三方框架（通过maven依赖的方式将比较繁琐的固定包依赖关系通过maven继承的方式全部依赖起来）完全采用注解化,在SpringBoot的过程中基本上没有使用XML，以简化XML的配置其内置HTTP服务器（tomcate,jetty）</p>
<p>（2）优点</p>
<p>使编码变得简单：推荐使用注解，组件自动装配，外部化配置，高度封装，开箱即用。</p>
<p>使配置变得简单：约定大于配置，主流框架无配置集成，专注核心业务，提供快速集成新技术、快速构建、自动配置的能力。</p>
<p>使部署变得简单：内嵌Tomcat、Jetty等Web容器，支持独立运行。</p>
<p>监控变得简单：自带项目监控实现。</p>
<p>（3）常用注解</p>
<p>SpringBootApplication：SpringBoot最核心的注解，用在 Spring Boot的主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。实际上这个注解是@Configuration,@EnableAutoConfiguration,@ComponentScan三个注解的组合。由于这些注解一般都是一起使用，所以Spring Boot提供了一个统一的注解@SpringBootApplication。</p>
<p>EnableAutoConfiguratio：允许SpringBoot自动配置注解，开启这个注解之后，SpringBoot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p>
<p>Configuration：定义配置类，指出该类是 Bean 配置的信息源，相当于传统的xml配置文件，一般加在主类上。</p>
<p>ComponentScan：组件扫描让，spring Boot扫描到Configuration类并把它加入到程序上下文。@ComponentScan注解默认就会装配标识了@Controller，@Service，@Repository，@Component注解的类到spring容器中。</p>
<p>Service：一般用于修饰service层的组件</p>
<p>RestController：标注为控制层组件</p>
<p>ResponseBody：表示该方法的返回结果直接写入HTTP response body中一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p>
<p>Bean：相当于XML中的<bean></bean>,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p>
<p>Autowired：把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作</p>
<h1 id="SpringClound"><a href="#SpringClound" class="headerlink" title="SpringClound"></a>SpringClound</h1><p>（1）总结</p>
<p>springclound是基于Springboot和Spring的集成应用程序，提供与外部系统的继承，更专注于服务治理，微服务框架</p>
<p>（2）核心组件</p>
<p>1）注册中心：Nacos（阿里）、Eureka（NetFix）</p>
<p>2）负载均衡：Ribbon（NetFix）、Loadbalancer（官网）</p>
<p>3）远程调用：Openfeign（官方）</p>
<p>4）熔断器：Hystrix（NetFix）、Sentinesl（阿里）、Resilience4J（官方）</p>
<p>5）网关：Zuul（netfix）、SpringCloundGateWay（官方）</p>
<p>6）配置中心：SrpingCloundConfig（官方）、Nacos（阿里）、Apollo（携程）</p>
<p>（3）服务发现</p>
<p>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。</p>
<p>这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient  同一个服务修改端口就可以启动多个实例。</p>
<p>（4）服务熔断和服务降级</p>
<p>1）熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</p>
<p>2）服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。</p>
<p>Hystrix相关注解：</p>
<p>​    @EnableHystrix：开启熔断</p>
<p>​    @HystrixCommand(fallbackMethod&#x3D;”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</p>
<h1 id="数据库Sql"><a href="#数据库Sql" class="headerlink" title="数据库Sql"></a>数据库Sql</h1><p>（1）三大范式</p>
<p>　    第一范式（1NF）：字段不可分；<br>　　第二范式（2NF）：有主键，非主键字段依赖主键；<br>　　第三范式（3NF）：非主键字段不能相互依赖。</p>
<p>​       1NF：原子性。 字段不可再分,否则就不是关系数据库;；<br>　　2NF：唯一性 。一个表只说明一个事物；<br>　　3NF：每列都与主键有直接关系，不存在传递依赖。</p>
<p>（2）存储过程</p>
<p>（3）sql优化</p>
<p>1）尽量避免全表扫描，应该在where或者order by涉及的表上建立索引</p>
<p>2）尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
<p>3）尽量避免在where子句中使用！&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p>
<p>4）避免在where子句中使用or来连接条件，否则将引擎放弃使用索引而进行全表扫描</p>
<p>5）in和not in也要慎用，否则会导致全表扫描</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>（1）总结</p>
<p>Redis是nosql型数据库，也称为这个缓存数据库，他是单线程的，并且全部的数据都是存储在内存里面，所以它比较快</p>
<p>他的数据类型呢有五个分别是String，set，list，hash，sorted set</p>
<p>(1)String是简单的key-value类型，value可以是字符串及数字。value是数字时可以充当原子计数器。使<br>用String类型可以完全实现Memcache的功能。<br>(2) Hash结构，Memcache中，我们经常把结构化的信息放入Java的数据结构HashMap中，采用<br>Jackson或FastJson序列化JSON字符串后采用String形式存储。如果程序要修改某一项时，通常把JSON<br>字符串取出后再反序列化为HashMap，然后再次序列化存储。简单修改一个属性干这么多事情，消耗必<br>定很大，它不适合并发操作的场合（比如两个并发操作都要修改积分）。而采用Hash结构避免了这种尴<br>尬；<br>(3) List结构, 使用场景有最新消息排行，采用list的push及pop操作可以实现一个简单的消息队列；可以<br>使用List或Hash结构实现购物车功能；<br>(4) Set结构，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一<br>个集合。因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实<br>现如共同关注、共同喜好、二度好友等功能；<br>(5)ZSet结构，ZSet是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行<br>有序排列，比如一个存储全班同学成绩的ZSet，其集合 value 可以是同学的学号，而 score 就可以是其<br>考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带<br>权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒<br>序来获取工作任务。让重要的任务优先执行。</p>
<p>（2）缓存雪崩</p>
<p>大量的应用请求无法在Redis缓存中进行处理，紧接着应用将大量请求发送到数据库层，导致数据库层的压力激增</p>
<p>击穿与雪崩的区别即在于击穿是对于特定的热点数据来说，而雪崩是全部数据。</p>
<p>解决方案<br>服务降级<br>允许核心业务访问数据库，非核心业务直接返回预定义的信息<br>不设置过期时间<br>服务熔断<br>暂停业务应用对缓存服务的访问，从而降低对数据库的压力</p>
<p>（3）缓存穿透<br>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打倒数据库上。<br>即这个数据根本不存在，如果黑客攻击时，启用很多个线程，<br>一直对这个不存在的数据发送请求 ，那么请求就会一直被打到数据库上，很容易将数据库打崩。<br>解决方式：<br>缓存空对象<br>布隆过滤器</p>
<p>（4）缓存击穿<br>缓存击穿是指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，<br>从而大量的请求打到db（数据库），属于常见的“热点”问题<br>1.预先设置热门数据，提前存入缓存</p>
<p>2.实时监控热门数据，调整key过期时长</p>
<p>3.二级缓存:对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间。</p>
<p>4.设置分布式锁</p>
<p>服务熔断就是应对缓存雪崩的一种措施，暂停业务应用对缓存服务的访问，从而降低对数据库的压力</p>
<p>服务降级允许核心业务访问数据库，非核心业务直接返回预定义的信息</p>
<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p>（1）总结</p>
<p>ES是基于Lucene的搜索引擎应用服务器，他提供了一个分布式多用户能力的全文搜索引擎，且ES支持RestFul风格的url访问</p>
<p>（2）倒排索引</p>
<p>主要作用就是将你的整个语句进行分词处理</p>
<p>（1）正排索引</p>
<p>简单来说：就是查询原始数据</p>
<p>（2）倒排索引</p>
<p>索引是整个搜索引擎中的关键，ES中为了快速准确的查询，使用了一个特殊的概念来进行数据的存储和查询，这个概念我们称之为倒排索引，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含他的文档列表、</p>
<p>简单来说：就是查询原始数据的分词结果</p>
<p>（3）ik分词器</p>
<blockquote>
<p>注意：必须和Elasticsearch版本一致</p>
</blockquote>
<p>由于es默认是没有中文分词器的，专门针对es对中文不是特别友好的所开发的一个插件</p>
<p>（1）将一块文本分成适合于倒排索引的独立词条</p>
<p>（2）将这些词条统一化为标准格式以提高他们的可扩展性</p>
<p>lK分词器提供了两个分词算法:<br>（1）ik_smart:最少切分，已经出现在分词中的文字，则不会继续参与其他分词。</p>
<p>（2） ik_max_word:最细粒度切分，按照所有分词的可能性进行分词。</p>
<p>（1）自定义词库</p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>（1）总结</p>
<p>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件。</p>
<p>（2）优点</p>
<p>异步处理 ：相比于传统的串行、并行方式，提高了系统吞吐量。<br>应用解耦 ： 系统间通过消息通信，不用关心其他系统的处理。<br>流量削锋 ：可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。<br>日志处理 ：解决大量日志传输。<br>消息通讯 ： 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消<br>息队列，或者聊天室等</p>
<p>（3）应用场景</p>
<p>1）服务间异步通信</p>
<p>2）顺序消费</p>
<p>3）采用死信实现限时任务</p>
<p>4）请求削峰</p>
<p>（4）工作模式</p>
<p>1）Simple简单收发模式</p>
<p>2）work queues工作队列模式</p>
<p>3）public&#x2F;subscribe发布订阅（共享资源）</p>
<p>4）Routing路由模式</p>
<p>5）topic主题模式</p>
<h1 id="Linux（操作系统）VM（虚拟机）"><a href="#Linux（操作系统）VM（虚拟机）" class="headerlink" title="Linux（操作系统）VM（虚拟机）"></a>Linux（操作系统）VM（虚拟机）</h1><p>（1）常用命令</p>
<p>1）登录与注销</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1)	sudo useradd lilei  //添加用户 (不能被立即使用，需设置密码 sudo passwd lilei)  </span><br><span class="line">2)	sudo adduser lilei  //添加用户</span><br><span class="line">3)	login  //登录或切换用户</span><br><span class="line">4)	logout //注销用户（命令行）  exit(shell-退出控制台)</span><br><span class="line">5)	shutdown -h 10  //10分钟后自动关机	shutdown -c  //取消</span><br><span class="line">6)	halt(root用户)  //关闭所有进程后自动关机</span><br><span class="line">7)	poweroff //同上</span><br><span class="line">8)	shutdown -r 10 //十分钟后自动重启</span><br><span class="line">9)	init 6  //重启 （0-停机，1-单用户，2-多用户，3-完全多用户，4-图形化，5-安全模式，6-重启）</span><br><span class="line">10)	reboot  //重启</span><br></pre></td></tr></table></figure>

<p>2）目录与文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1)	pwd   //显示当前工作目录</span><br><span class="line">2)	mkdir mydir  //创建工作目录</span><br><span class="line">3)	cd mydir  //更改工作目录</span><br><span class="line">4)	rmdir mydir //删除工作目录</span><br><span class="line">5)	touch myfile  //创建文件</span><br><span class="line">6)	mv myfile mydir  //移动目录或文件</span><br><span class="line">7)	cp myfile myfir  //复制目录或文件</span><br><span class="line">8)	rm -rf mydir  //删除目录或文件</span><br><span class="line">9)	ls -l myfile  //查看文件最后被编辑时间</span><br><span class="line">10)	ls -lu myfile //查看文件最后被访问时间</span><br><span class="line">11)	touch -at 01011212 myfile  //修改文件最后被访问时间</span><br><span class="line">12)	ls //列出所有文件和目录</span><br><span class="line">13)	ls -a //查看所有文件</span><br><span class="line">14)	ls -i //显示文件索引节点号</span><br><span class="line">15)	ls -l //详细显示</span><br><span class="line">16)	ls -m //以逗号分隔</span><br><span class="line">17)	sudo apt-get install tree </span><br><span class="line">18)	tree -l//以树状图列出目录内容</span><br><span class="line">19)	tree -a //所有</span><br><span class="line">20)	tree -i //不以阶梯状</span><br><span class="line">21)	tree -s  //列出文件或目录大小</span><br><span class="line">22)	tree -t  //按更改时间</span><br><span class="line">23)	file -b myfile  //显示目录或文件的详细信息</span><br><span class="line">24)	stat myfile  //同上</span><br></pre></td></tr></table></figure>

<p>3）文件内容显示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1)	cat &gt; myfile  //创建文件并编辑内容（ctrl+D结束编辑）</span><br><span class="line">2)	cat -n myfile  //查看文件</span><br><span class="line">3)	chmod [u/g/o/a][+/-/=][r/w/x] myfile  //更改文件权限</span><br><span class="line">u-user,g-group,o-others,a-all  .   +-添加,--删除,=-重置   .</span><br><span class="line">r-read读（4），w-write写（2），x-execute执行（1）</span><br><span class="line">4)	more myfile  //分页往后显示文件（Space空格）</span><br><span class="line">5)	less myfile  //分页自由显示文件（Page Down / Page Up）</span><br><span class="line">6)	head (-10) myfile  //指定显示文件前若干行（默认前10）</span><br><span class="line">7)	tail (-10) myfile  //指定显示文件后若干行（默认后10）</span><br></pre></td></tr></table></figure>

<p>4）文件内容处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1)	sort myfile  //对文件内容进行排序</span><br><span class="line">2)	sort -r myfile  //逆序</span><br><span class="line">3)	uniq myfile  //检查文件中的重复内容</span><br><span class="line">4)	grep （-c）‘a’ myfile  //在文件中查找指定内容 (显示行号)</span><br><span class="line">5)	diff myfile01 myfile02  //对不同文件进行比较</span><br><span class="line">6)	diff3 myfile01 myfile02 myfile03  //三个文件</span><br><span class="line">7)	sdiff myfile01 myfile02  //合并</span><br><span class="line">8)	cmp myfile01 myfile02  //通过字节对不同文件进行比较</span><br><span class="line">9)	comm myfile01 myfile02  //对有序文件进行比较</span><br><span class="line">10)	cut -b(-c)(-d) 2(3) myfile  //对文件内容进行剪切</span><br><span class="line">11)	paste myfile02 myfile01 //对文件内容进行粘贴 02-）01</span><br><span class="line">12)	wc （-参数） myfile  //对文件内容进行统计 （c-字符数,w-单词数,l-行数）</span><br></pre></td></tr></table></figure>

<p>5）压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1)	zip myfile.zip myfile  //压缩</span><br><span class="line">2)	zip -d myfile.zip myfile  //添加</span><br><span class="line">3)	zip -m myfile.zip myfile  //删除</span><br><span class="line">4)	unzip -o myfile.zip  //解压（覆盖）</span><br><span class="line">5)	unzip -n myfile.zip  //解压（不覆盖）</span><br><span class="line">6)	zipinfo myfile.zip  //列出压缩文件信息</span><br></pre></td></tr></table></figure>

<p>6）获取帮助</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1)	man ls  //获取帮助</span><br><span class="line">2)	man -k ls  //不清楚完整名字</span><br><span class="line">3)	whatis ls  //获取帮助</span><br><span class="line">4)	help cd  / cd –help  //获取帮助 -d(简短描述) -s(用法简介)</span><br><span class="line">5)	info who  //获取帮助</span><br></pre></td></tr></table></figure>

<p>7）其他命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1)	clear  //清楚屏幕信息</span><br><span class="line">2)	echo xx  //显示文本  x=0  echo $x . echo -e \$x . echo $(pwd)</span><br><span class="line">3)	date  //显示日期和时间（+%y 年  +%m 月  +%d日）</span><br><span class="line">4)	cal  //显示当前日期  cal -y</span><br><span class="line">5)	ps  //查看当前进程  -A(所有)  U  lilei (用户lilei)</span><br><span class="line">6)	kill -9 2315  //终止某一进程  </span><br><span class="line">7)	ps -ef | grep Jincheng</span><br><span class="line">8)	pkill Jincheng</span><br><span class="line">9)	killall Jincheng</span><br><span class="line">10)	last  //显示最近登录系统的用户信息-6列</span><br><span class="line">11)	history （10） //显示历史指令-默认1000行</span><br><span class="line">12)	sudo adduser lilei sudo  //给普通用户赋予root权限</span><br><span class="line">13)	sudo usermod -G sudo lilei  //同上</span><br><span class="line">14)	alias l=’ls’  //定义命令别名</span><br><span class="line">15)	unalias l  //删除别名</span><br><span class="line">16)	alias  //列出别名</span><br></pre></td></tr></table></figure>

<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p> 创建一个文件：vim 文件名</p>
<p>添加到缓存区：git add 文件名</p>
<p>提交到本地区：git commit -m “版本号” 文件名</p>
<p>查看状态：git status</p>
<p>查看版本：git reflog</p>
<p>查看详细版本：git log</p>
<p>查看文件：cat 文件名</p>
<p>查看分支：</p>
<p>切换分支：git checkout 分支名</p>
<p>添加分支：</p>
<p>给远程库路径起别名：git remote add 别名 路径名</p>
<p>查看路径：git remote -v</p>
<p>推送到github：git push 路径名 分支名</p>
<p> 拉取到本地仓库：git pull 路径名 分支名</p>
<p>复制：git clone 路径名</p>
<p>（1）常用命令</p>
<p>git安装后-指定名称和邮箱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line"> </span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>创建版本库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit	//创建</span><br><span class="line">$ cd learngit	//使用</span><br><span class="line">$ pwd	//查看当前目录</span><br><span class="line">$ git init	//初始化，生成.git文件(若该文件隐藏，则使用ls -ah)</span><br></pre></td></tr></table></figure>

<p>把文件添加add和提交commit到版本库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt	//添加</span><br><span class="line">$ git commit -m &quot;wrote a test file&quot;	//提交</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;		//一次性提交多个文件</span><br></pre></td></tr></table></figure>

<p>版本控制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log	//查看提交历史记录，从最近到最远，可以看到3次</span><br><span class="line">$ git log --pretty=oneline	//加参，简洁查看</span><br><span class="line">$ git reflog	//查看每一次修改历史</span><br><span class="line">$ cat test.txt	//查看文件内容</span><br><span class="line">$ git status	//查看工作区中文件当前状态</span><br><span class="line">$ git reset --hard HEAD^（HEAD~100）（commit id）	//回退版本</span><br><span class="line">$ git checkout -- test.txt	//丢弃工作区的修改，即撤销修改</span><br><span class="line">$ git reset HEAD test.txt	//丢弃暂存区的修改（若已提交，则回退）</span><br></pre></td></tr></table></figure>

<p>删除文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br><span class="line">//直接删除</span><br><span class="line">$ git rm test.txt</span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">//删错了，恢复</span><br><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<p>远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;	//创建SSH Key</span><br><span class="line">$ git remote add origin git@github.com:Daisy/AKgit.git	//关联</span><br><span class="line">$ git push -u origin master	//将本地内容推送到远程仓库（第一次）</span><br><span class="line">$ git push origin master	//将本地内容推送到远程仓库（之后）</span><br><span class="line">$ git remote -v        //查看远程仓库信息</span><br><span class="line">$ git remote rm origin	//删除远程仓库（解绑）</span><br><span class="line">$ git clone git@github.com: Daisy/AKgit.git	//克隆远程仓库</span><br><span class="line">//克隆之后使用和查看</span><br><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">$ git remote	//查看远程库的信息</span><br><span class="line">$ git remote -v	//查看远程库的详细信息</span><br></pre></td></tr></table></figure>

<p>多人协作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev	//创建并切换到分支dev</span><br><span class="line">//创建并切换到分支dev，同上</span><br><span class="line">$ git branch dev	//创建</span><br><span class="line">$ git checkout dev	//切换</span><br><span class="line">//新版本</span><br><span class="line">$ git switch -c dev	//创建并切换到分支dev</span><br><span class="line">$ git switch master	//直接切换分支</span><br><span class="line">$ git branch		//查看当前分支</span><br><span class="line">$ git merge dev	（--no-ff）(-m)//合并，把dev分支的工作成果合并到master分支上</span><br><span class="line">$ git branch -d dev	//删除dev分支 </span><br><span class="line">$ git stash	//将现场储藏起来</span><br><span class="line">$ git stash list	//查看储存的工作现场</span><br><span class="line">//恢复和删除</span><br><span class="line">$ git stash apply</span><br><span class="line">$ git stash drop</span><br><span class="line">//恢复并删除</span><br><span class="line">$ git stash pop</span><br><span class="line">$ git cherry-pick 4c805e2	//复制修改</span><br><span class="line">$ git push origin master（dev）	//推送分支</span><br><span class="line">$ git checkout -b dev origin/dev	//创建远程origin的dev分支到本地</span><br><span class="line">$ git pull	//抓取分支（解决冲突）</span><br><span class="line">$ git branch --set-upstream-to=origin/dev dev//指定本地与远程dev的链接</span><br><span class="line">$ git rebase	//把本地未push的分叉提交历史整理成直线</span><br></pre></td></tr></table></figure>

<p>标签管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0	//打标签</span><br><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb //指定标签名和说明文字</span><br><span class="line">$ git tag	//查看所有标签</span><br><span class="line">//若是忘记打，则查找历史提交commit id ，再打上</span><br><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">$ git tag v0.9 f52c633</span><br><span class="line">$ git show v0.9		//查看标签详细信息</span><br><span class="line">$ git tag -d v0.1	//删除标签</span><br><span class="line">$ git push origin v1.0	//推送标签到远程</span><br><span class="line">$ git push origin –tags	//一次性推送全部本地标签</span><br><span class="line">//删除标签，（若已推送到远程，先从本地删除，从远程删除）</span><br><span class="line">$ git tag -d v0.9</span><br><span class="line">$ git push origin :refs/tags/v0.9 </span><br></pre></td></tr></table></figure>

<p>自定义git</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui true	//让git显示颜色</span><br><span class="line">//忽略特殊文件</span><br><span class="line">//.gitignore文件</span><br><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br><span class="line">//把该文件也提交到git</span><br><span class="line">$ git add -f App.class		//强制添加被忽略的特殊文件</span><br><span class="line">$ git check-ignore -v App.class	//检查哪个规则出错</span><br><span class="line"># 排除所有.开头的隐藏文件:</span><br><span class="line">.*</span><br><span class="line"># 排除所有.class文件:</span><br><span class="line">*.class</span><br><span class="line"># 不排除.gitignore和App.class:</span><br><span class="line">!.gitignore</span><br><span class="line">!App.class</span><br><span class="line">$ git config --global alias.st status	//配置别名</span><br><span class="line">$ git config --global alias.unstage &#x27;reset HEAD&#x27;  //配置操作别名</span><br><span class="line">$ git config --global alias.last &#x27;log -1&#x27;	//显示最后一次提交信息</span><br><span class="line">$ git last	//显示最近一次的提交</span><br><span class="line">$git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;  //颜色</span><br><span class="line">$ cat .git/config //查看每个仓库的git配置文件</span><br><span class="line">$ cat .gitconfig  //查看当前用户的git配置文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>（1）常用命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">-D 指定参数，如 -Dmaven.test.skip=true 跳过单元测试；</span><br><span class="line"></span><br><span class="line">-P 指定 Profile 配置，可以用于区分环境；</span><br><span class="line"></span><br><span class="line">-e 显示maven运行出错的信息；</span><br><span class="line"></span><br><span class="line">-o 离线执行命令,即不去远程仓库更新包；</span><br><span class="line"></span><br><span class="line">-X 显示maven允许的debug信息；</span><br><span class="line"></span><br><span class="line">-U 强制去远程更新snapshot的插件或依赖，默认每天只更新一次。</span><br><span class="line"></span><br><span class="line">常用maven命令</span><br><span class="line">创建maven项目：mvn archetype:create</span><br><span class="line">指定 group： -DgroupId=packageName</span><br><span class="line"></span><br><span class="line">指定 artifact：-DartifactId=projectName</span><br><span class="line"></span><br><span class="line">创建web项目：-DarchetypeArtifactId=maven-archetype-webapp</span><br><span class="line"></span><br><span class="line">创建maven项目：mvn archetype:generate</span><br><span class="line">验证项目是否正确：mvn validate</span><br><span class="line">maven 打包：mvn package</span><br><span class="line">只打jar包：mvn jar:jar</span><br><span class="line">生成源码jar包：mvn source:jar</span><br><span class="line">产生应用需要的任何额外的源代码：mvn generate-sources</span><br><span class="line">编译源代码： mvn compile</span><br><span class="line">编译测试代码：mvn test-compile</span><br><span class="line">运行测试：mvn test</span><br><span class="line">运行检查：mvn verify</span><br><span class="line">清理maven项目：mvn clean</span><br><span class="line">生成eclipse项目：mvn eclipse:eclipse</span><br><span class="line">清理eclipse配置：mvn eclipse:clean</span><br><span class="line">生成idea项目：mvn idea:idea</span><br><span class="line">安装项目到本地仓库：mvn install</span><br><span class="line">发布项目到远程仓库：mvn:deploy</span><br><span class="line">在集成测试可以运行的环境中处理和发布包：mvn integration-test</span><br><span class="line">显示maven依赖树：mvn dependency:tree</span><br><span class="line">显示maven依赖列表：mvn dependency:list</span><br><span class="line">下载依赖包的源码：mvn dependency:sources</span><br><span class="line">安装本地jar到本地仓库：mvn install:install-file -DgroupId=packageName -DartifactId=projectName -Dversion=version -Dpackaging=jar -Dfile=path</span><br><span class="line">web项目相关命令</span><br><span class="line">启动tomcat：mvn tomcat:run</span><br><span class="line">启动jetty：mvn jetty:run</span><br><span class="line">运行打包部署：mvn tomcat:deploy</span><br><span class="line">撤销部署：mvn tomcat:undeploy</span><br><span class="line">启动web应用：mvn tomcat:start</span><br><span class="line">停止web应用：mvn tomcat:stop</span><br><span class="line">重新部署：mvn tomcat:redeploy</span><br></pre></td></tr></table></figure>

<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>（1）生命周期</p>
<ol>
<li>beforeCreate（创建前）</li>
<li>created （创建后）</li>
<li>beforeMount (载入前)</li>
<li>mounted （载入后）</li>
<li>beforeUpdate （更新前）</li>
<li>updated   （更新后）</li>
<li>beforeDestroy（ 销毁前）</li>
<li>destroyed （销毁后）</li>
</ol>
<p>（2）</p>
<p>额外面试遇见：<br>（1）抽取公共前缀，没有则返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] a = &#123;<span class="string">&quot;flsaiyut&quot;</span>,<span class="string">&quot;flbatsda&quot;</span>,<span class="string">&quot;fldardasda&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        abc:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">a2</span> <span class="operator">=</span> a1.charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j].charAt(i)!=a2)&#123;</span><br><span class="line">                   <span class="keyword">break</span> abc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            b+=a2;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）把字符串里面的逗号拆分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span><span class="string">&quot;a,b,c,d,e,f,g&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> a.toUpperCase();<span class="comment">//字符串英文字符转大写toUpperCase();</span></span><br><span class="line">        <span class="comment">//split（regex,limit）用法详解</span></span><br><span class="line">        <span class="comment">//- regex -- 正则表达式分隔符。</span></span><br><span class="line">        <span class="comment">// - limit -- 分割的份数。</span></span><br><span class="line">        String[] a1 = b.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>;i&lt;a1.length;i++)&#123;</span><br><span class="line">            System.out.print(a1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String[] a2 =&#123;<span class="string">&quot;A,B,C,D,E,F,G&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a3</span> <span class="operator">=</span> a2[<span class="number">0</span>].toLowerCase();<span class="comment">//字符串英文字符转小写toLowerCase()</span></span><br><span class="line">        String[] a4 = a3.split(<span class="string">&quot;,&quot;</span>);<span class="comment">//截取,</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a4.length;i++)&#123;</span><br><span class="line">            System.out.print(a4[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）对数字进行一个排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1)冒泡排序</span></span><br><span class="line"><span class="keyword">package</span> com.hdax.dm.user.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Six</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(a.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">////相邻两个元素作比较，如果前面元素大于后面，进行交换</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                    a[j] = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.print(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            
        </div>
        <footer class="article-footer">
            <a data-url="https://rxxyandysfx.github.io/2023/07/04/%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cljnn80u10003dwv0dihi52sb" data-title="Java面试题"
               class="article-share-link">分享</a>
            
            
        </footer>
    </div>
    
        
    <nav id="article-nav">
        
        
            <div class="article-nav-link-wrap article-nav-link-right">
                
                    <img data-src="https://s1.ax1x.com/2023/05/27/p9qjMHe.jpg" data-sizes="auto" alt="工程资料表修改接口"
                         class="lazyload">
                
                <a href="/2023/05/27/%E5%B7%A5%E7%A8%8B%E8%B5%84%E6%96%99%E8%A1%A8%E4%BF%AE%E6%94%B9%E6%8E%A5%E5%8F%A3/"></a>
                <div class="article-nav-caption">后一篇</div>
                <div class="article-nav-title">
                    
                        工程资料表修改接口
                    
                </div>
            </div>
        
    </nav>

    
</article>

</section>
                
                    <aside id="sidebar">
    <div class="sidebar-wrap">
        <div class="sidebar-author">
            <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="小白" class="lazyload">
            <div class="sidebar-author-name">小白</div>
            <div class="sidebar-description"></div>
        </div>
        <div class="sidebar-state">
            <div class="sidebar-state-article">
                <div>文章</div>
                <div class="sidebar-state-number">3</div>
            </div>
            <div class="sidebar-state-category">
                <div>分类</div>
                <div class="sidebar-state-number">0</div>
            </div>
            <div class="sidebar-state-tag">
                <div>标签</div>
                <div class="sidebar-state-number">0</div>
            </div>
        </div>
        <div class="sidebar-social">
            
                <div class=icon-github>
                    <a href=https://github.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-google>
                    <a href=https://plus.google.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-twitter>
                    <a href=https://twitter.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-facebook>
                    <a href=https://www.facebook.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
        </div>
        <div class="sidebar-menu">
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">首页</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/archives"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">归档</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/about"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">关于</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/friend"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">友链</div>
                </div>
            
        </div>
    </div>
    
        

    
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
        </div>
    </div>


    
</aside>
                
            </div>
            <footer id="footer">
    <div class="footer-line"></div>
    <div class="outer">
        <div id="footer-info" class="inner">
            
            <div>
                <span class="icon-copyright"></span>
                2020-2023
                <span class="footer-info-sep"></span>
                小白
            </div>
            
                <div>
                    基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
                    Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
                </div>
            
            
                <div>
                    <span class="icon-brush"></span>
                    29k
                    &nbsp;|&nbsp;
                    <span class="icon-coffee"></span>
                    01:59
                </div>
            
            
                <div>
                    <span class="icon-eye"></span>
                    <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
                    &nbsp;|&nbsp;
                    <span class="icon-user"></span>
                    <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
                </div>
            
        </div>
    </div>
</footer>
  
        </div>
        <nav id="mobile-nav">
    <div class="sidebar-wrap">
        <div class="sidebar-author">
            <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="小白" class="lazyload">
            <div class="sidebar-author-name">小白</div>
            <div class="sidebar-description"></div>
        </div>
        <div class="sidebar-state">
            <div class="sidebar-state-article">
                <div>文章</div>
                <div class="sidebar-state-number">3</div>
            </div>
            <div class="sidebar-state-category">
                <div>分类</div>
                <div class="sidebar-state-number">0</div>
            </div>
            <div class="sidebar-state-tag">
                <div>标签</div>
                <div class="sidebar-state-number">0</div>
            </div>
        </div>
        <div class="sidebar-social">
            
                <div class=icon-github>
                    <a href=https://github.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-google>
                    <a href=https://plus.google.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-twitter>
                    <a href=https://twitter.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-facebook>
                    <a href=https://www.facebook.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
        </div>
        <div class="sidebar-menu">
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">首页</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/archives"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">归档</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/about"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">关于</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/friend"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">友链</div>
                </div>
            
        </div>
    </div>
</nav>
        
<script src="https://unpkg.com/jquery@3.6.3/dist/jquery.min.js"></script>


<script src="https://unpkg.com/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://unpkg.com/clipboard@2.0.11/dist/clipboard.min.js"></script>



    
<script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>



    
<script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script>






<script src="/js/script.js"></script>


    




    </div>
    <div class="site-search">
        <div class="algolia-popup popup">
            <div class="algolia-search">
                <span class="algolia-search-input-icon"></span>
                <div class="algolia-search-input" id="algolia-search-input"></div>
            </div>

            <div class="algolia-results">
                <div id="algolia-stats"></div>
                <div id="algolia-hits"></div>
                <div id="algolia-pagination" class="algolia-pagination"></div>
            </div>

            <span class="popup-btn-close"></span>
        </div>
    </div>
    <!-- hexo injector body_end start -->
<script src="/js/insertHighlight.js"></script>
<!-- hexo injector body_end end --></body>
    </html>

